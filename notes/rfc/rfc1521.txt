Network Working Group																			N. Borenstein
Request for Comments: 1521																			Bellcore
Obsoletes: 1341																								 N. Freed
Category: Standards Track																			 Innosoft
																													September 1993


				 MIME (Multipurpose Internet Mail Extensions) Part One:
								Mechanisms for Specifying and Describing
								 the Format of Internet Message Bodies

Status of this Memo

	 This RFC specifies an Internet standards track protocol for the
	 Internet community, and requests discussion and suggestions for
	 improvements.	Please refer to the current edition of the "Internet
	 Official Protocol Standards" for the standardization state and status
	 of this protocol.	Distribution of this memo is unlimited.

Abstract

	 STD 11, RFC 822 defines a message representation protocol which
	 specifies considerable detail about message headers, but which leaves
	 the message content, or message body, as flat ASCII text.	This
	 document redefines the format of message bodies to allow multi-part
	 textual and non-textual message bodies to be represented and
	 exchanged without loss of information.	This is based on earlier work
	 documented in RFC 934 and STD 11, RFC 1049, but extends and revises
	 that work.	Because RFC 822 said so little about message bodies, this
	 document is largely orthogonal to (rather than a revision of) RFC
	 822.

	 In particular, this document is designed to provide facilities to
	 include multiple objects in a single message, to represent body text
	 in character sets other than US-ASCII, to represent formatted multi-
	 font text messages, to represent non-textual material such as images
	 and audio fragments, and generally to facilitate later extensions
	 defining new types of Internet mail for use by cooperating mail
	 agents.

	 This document does NOT extend Internet mail header fields to permit
	 anything other than US-ASCII text data.	Such extensions are the
	 subject of a companion document [RFC-1522].

	 This document is a revision of RFC 1341.	Significant differences
	 from RFC 1341 are summarized in Appendix H.





Borenstein & Freed																							[Page 1]

RFC 1521													MIME										September 1993


Table of Contents

	 1.		 Introduction.......................................	3
	 2.		 Notations, Conventions, and Generic BNF Grammar....	6
	 3.		 The MIME-Version Header Field......................	7
	 4.		 The Content-Type Header Field......................	9
	 5.		 The Content-Transfer-Encoding Header Field......... 13
	 5.1.	 Quoted-Printable Content-Transfer-Encoding......... 18
	 5.2.	 Base64 Content-Transfer-Encoding................... 21
	 6.		 Additional Content-Header Fields................... 23
	 6.1.	 Optional Content-ID Header Field................... 23
	 6.2.	 Optional Content-Description Header Field.......... 24
	 7.		 The Predefined Content-Type Values................. 24
	 7.1.	 The Text Content-Type.............................. 24
	 7.1.1. The charset parameter.............................. 25
	 7.1.2. The Text/plain subtype............................. 28
	 7.2.	 The Multipart Content-Type......................... 28
	 7.2.1. Multipart:	The common syntax...................... 29
	 7.2.2. The Multipart/mixed (primary) subtype.............. 34
	 7.2.3. The Multipart/alternative subtype.................. 34
	 7.2.4. The Multipart/digest subtype....................... 36
	 7.2.5. The Multipart/parallel subtype..................... 37
	 7.2.6. Other Multipart subtypes........................... 37
	 7.3.	 The Message Content-Type........................... 38
	 7.3.1. The Message/rfc822 (primary) subtype............... 38
	 7.3.2. The Message/Partial subtype........................ 39
	 7.3.3. The Message/External-Body subtype.................. 42
	 7.3.3.1.	The "ftp" and "tftp" access-types............... 44
	 7.3.3.2.	The "anon-ftp" access-type...................... 45
	 7.3.3.3.	The "local-file" and "afs" access-types......... 45
	 7.3.3.4.	The "mail-server" access-type................... 45
	 7.3.3.5.	Examples and Further Explanations............... 46
	 7.4.	 The Application Content-Type....................... 49
	 7.4.1. The Application/Octet-Stream (primary) subtype..... 50
	 7.4.2. The Application/PostScript subtype................. 50
	 7.4.3. Other Application subtypes......................... 53
	 7.5.	 The Image Content-Type............................. 53
	 7.6.	 The Audio Content-Type............................. 54
	 7.7.	 The Video Content-Type............................. 54
	 7.8.	 Experimental Content-Type Values................... 54
	 8.		 Summary............................................ 56
	 9.		 Security Considerations............................ 56
	 10.		Authors' Addresses................................. 57
	 11.		Acknowledgements................................... 58
	 Appendix A -- Minimal MIME-Conformance.................... 60
	 Appendix B -- General Guidelines For Sending Email Data... 63
	 Appendix C -- A Complex Multipart Example................. 66
	 Appendix D -- Collected Grammar........................... 68



Borenstein & Freed																							[Page 2]

RFC 1521													MIME										September 1993


	 Appendix E -- IANA Registration Procedures................ 72
	 E.1	Registration of New Content-type/subtype Values...... 72
	 E.2	Registration of New Access-type Values
				for Message/external-body............................ 73
	 Appendix F -- Summary of the Seven Content-types.......... 74
	 Appendix G -- Canonical Encoding Model.................... 76
	 Appendix H -- Changes from RFC 1341....................... 78
	 References................................................ 80

1.		Introduction

	 Since its publication in 1982, STD 11, RFC 822 [RFC-822] has defined
	 the standard format of textual mail messages on the Internet.	Its
	 success has been such that the RFC 822 format has been adopted,
	 wholly or partially, well beyond the confines of the Internet and the
	 Internet SMTP transport defined by STD 10, RFC 821 [RFC-821].	As the
	 format has seen wider use, a number of limitations have proven
	 increasingly restrictive for the user community.

	 RFC 822 was intended to specify a format for text messages.	As such,
	 non-text messages, such as multimedia messages that might include
	 audio or images, are simply not mentioned.	Even in the case of text,
	 however, RFC 822 is inadequate for the needs of mail users whose
	 languages require the use of character sets richer than US ASCII
	 [US-ASCII]. Since RFC 822 does not specify mechanisms for mail
	 containing audio, video, Asian language text, or even text in most
	 European languages, additional specifications are needed.

	 One of the notable limitations of RFC 821/822 based mail systems is
	 the fact that they limit the contents of electronic mail messages to
	 relatively short lines of seven-bit ASCII.	This forces users to
	 convert any non-textual data that they may wish to send into seven-
	 bit bytes representable as printable ASCII characters before invoking
	 a local mail UA (User Agent, a program with which human users send
	 and receive mail). Examples of such encodings currently used in the
	 Internet include pure hexadecimal, uuencode, the 3-in-4 base 64
	 scheme specified in RFC 1421, the Andrew Toolkit Representation
	 [ATK], and many others.

	 The limitations of RFC 822 mail become even more apparent as gateways
	 are designed to allow for the exchange of mail messages between RFC
	 822 hosts and X.400 hosts. X.400 [X400] specifies mechanisms for the
	 inclusion of non-textual body parts within electronic mail messages.
	 The current standards for the mapping of X.400 messages to RFC 822
	 messages specify either that X.400 non-textual body parts must be
	 converted to (not encoded in) an ASCII format, or that they must be
	 discarded, notifying the RFC 822 user that discarding has occurred.
	 This is clearly undesirable, as information that a user may wish to



Borenstein & Freed																							[Page 3]

RFC 1521													MIME										September 1993


	 receive is lost.	Even though a user's UA may not have the capability
	 of dealing with the non-textual body part, the user might have some
	 mechanism external to the UA that can extract useful information from
	 the body part.	Moreover, it does not allow for the fact that the
	 message may eventually be gatewayed back into an X.400 message
	 handling system (i.e., the X.400 message is "tunneled" through
	 Internet mail), where the non-textual information would definitely
	 become useful again.

	 This document describes several mechanisms that combine to solve most
	 of these problems without introducing any serious incompatibilities
	 with the existing world of RFC 822 mail.	In particular, it
	 describes:

	 1. A MIME-Version header field, which uses a version number to
			 declare a message to be conformant with this specification and
			 allows mail processing agents to distinguish between such
			 messages and those generated by older or non-conformant software,
			 which is presumed to lack such a field.

	 2. A Content-Type header field, generalized from RFC 1049 [RFC-1049],
			 which can be used to specify the type and subtype of data in the
			 body of a message and to fully specify the native representation
			 (encoding) of such data.

			 2.a. A "text" Content-Type value, which can be used to represent
						textual information in a number of character sets and
						formatted text description languages in a standardized
						manner.

			 2.b. A "multipart" Content-Type value, which can be used to
						combine several body parts, possibly of differing types of
						data, into a single message.

			 2.c. An "application" Content-Type value, which can be used to
						transmit application data or binary data, and hence, among
						other uses, to implement an electronic mail file transfer
						service.

			 2.d. A "message" Content-Type value, for encapsulating another
						mail message.

			 2.e An "image" Content-Type value, for transmitting still image
						(picture) data.

			 2.f. An "audio" Content-Type value, for transmitting audio or
						voice data.




Borenstein & Freed																							[Page 4]

RFC 1521													MIME										September 1993


			 2.g. A "video" Content-Type value, for transmitting video or
						moving image data, possibly with audio as part of the
						composite video data format.

	 3. A Content-Transfer-Encoding header field, which can be used to
			 specify an auxiliary encoding that was applied to the data in
			 order to allow it to pass through mail transport mechanisms which
			 may have data or character set limitations.

	 4. Two additional header fields that can be used to further describe
			 the data in a message body, the Content-ID and Content-
			 Description header fields.

	 MIME has been carefully designed as an extensible mechanism, and it
	 is expected that the set of content-type/subtype pairs and their
	 associated parameters will grow significantly with time.	Several
	 other MIME fields, notably including character set names, are likely
	 to have new values defined over time.	In order to ensure that the
	 set of such values is developed in an orderly, well-specified, and
	 public manner, MIME defines a registration process which uses the
	 Internet Assigned Numbers Authority (IANA) as a central registry for
	 such values.	Appendix E provides details about how IANA registration
	 is accomplished.

	 Finally, to specify and promote interoperability, Appendix A of this
	 document provides a basic applicability statement for a subset of the
	 above mechanisms that defines a minimal level of "conformance" with
	 this document.

			HISTORICAL NOTE: Several of the mechanisms described in this
			document may seem somewhat strange or even baroque at first
			reading.	It is important to note that compatibility with existing
			standards AND robustness across existing practice were two of the
			highest priorities of the working group that developed this
			document.	In particular, compatibility was always favored over
			elegance.

	 MIME was first defined and published as RFCs 1341 and 1342 [RFC-1341]
	 [RFC-1342].	This document is a relatively minor updating of RFC
	 1341, and is intended to supersede it.	The differences between this
	 document and RFC 1341 are summarized in Appendix H.	Please refer to
	 the current edition of the "IAB Official Protocol Standards" for the
	 standardization state and status of this protocol.	Several other RFC
	 documents will be of interest to the MIME implementor, in particular
	 [RFC 1343], [RFC-1344], and [RFC-1345].






Borenstein & Freed																							[Page 5]

RFC 1521													MIME										September 1993


2.		Notations, Conventions, and Generic BNF Grammar

	 This document is being published in two versions, one as plain ASCII
	 text and one as PostScript (PostScript is a trademark of Adobe
	 Systems Incorporated.).	While the text version is the official
	 specification, some will find the PostScript version easier to read.
	 The textual contents are identical.	An Andrew-format copy of this
	 document is also available from the first author (Borenstein).

	 Although the mechanisms specified in this document are all described
	 in prose, most are also described formally in the modified BNF
	 notation of RFC 822.	Implementors will need to be familiar with this
	 notation in order to understand this specification, and are referred
	 to RFC 822 for a complete explanation of the modified BNF notation.

	 Some of the modified BNF in this document makes reference to
	 syntactic entities that are defined in RFC 822 and not in this
	 document.	A complete formal grammar, then, is obtained by combining
	 the collected grammar appendix of this document with that of RFC 822
	 plus the modifications to RFC 822 defined in RFC 1123, which
	 specifically changes the syntax for `return', `date' and `mailbox'.

	 The term CRLF, in this document, refers to the sequence of the two
	 ASCII characters CR (13) and LF (10) which, taken together, in this
	 order, denote a line break in RFC 822 mail.

	 The term "character set" is used in this document to refer to a
	 method used with one or more tables to convert encoded text to a
	 series of octets.	This definition is intended to allow various kinds
	 of text encodings, from simple single-table mappings such as ASCII to
	 complex table switching methods such as those that use ISO 2022's
	 techniques.	However, a MIME character set name must fully specify
	 the mapping to be performed.

	 The term "message", when not further qualified, means either the
	 (complete or "top-level") message being transferred on a network, or
	 a message encapsulated in a body of type "message".

	 The term "body part", in this document, means one of the parts of the
	 body of a multipart entity. A body part has a header and a body, so
	 it makes sense to speak about the body of a body part.

	 The term "entity", in this document, means either a message or a body
	 part.	All kinds of entities share the property that they have a
	 header and a body.

	 The term "body", when not further qualified, means the body of an
	 entity, that is the body of either a message or of a body part.



Borenstein & Freed																							[Page 6]

RFC 1521													MIME										September 1993


			NOTE: The previous four definitions are clearly circular.	This is
			unavoidable, since the overall structure of a MIME message is
			indeed recursive.

	 In this document, all numeric and octet values are given in decimal
	 notation.

	 It must be noted that Content-Type values, subtypes, and parameter
	 names as defined in this document are case-insensitive.	However,
	 parameter values are case-sensitive unless otherwise specified for
	 the specific parameter.

			FORMATTING NOTE: This document has been carefully formatted for
			ease of reading.	The PostScript version of this document, in
			particular, places notes like this one, which may be skipped by
			the reader, in a smaller, italicized, font, and indents it as
			well.	In the text version, only the indentation is preserved, so
			if you are reading the text version of this you might consider
			using the PostScript version instead. However, all such notes will
			be indented and preceded by "NOTE:" or some similar introduction,
			even in the text version.

			The primary purpose of these non-essential notes is to convey
			information about the rationale of this document, or to place this
			document in the proper historical or evolutionary context.	Such
			information may be skipped by those who are focused entirely on
			building a conformant implementation, but may be of use to those
			who wish to understand why this document is written as it is.

			For ease of recognition, all BNF definitions have been placed in a
			fixed-width font in the PostScript version of this document.

3.		The MIME-Version Header Field

	 Since RFC 822 was published in 1982, there has really been only one
	 format standard for Internet messages, and there has been little
	 perceived need to declare the format standard in use.	This document
	 is an independent document that complements RFC 822. Although the
	 extensions in this document have been defined in such a way as to be
	 compatible with RFC 822, there are still circumstances in which it
	 might be desirable for a mail-processing agent to know whether a
	 message was composed with the new standard in mind.

	 Therefore, this document defines a new header field, "MIME-Version",
	 which is to be used to declare the version of the Internet message
	 body format standard in use.

	 Messages composed in accordance with this document MUST include such



Borenstein & Freed																							[Page 7]

RFC 1521													MIME										September 1993


	 a header field, with the following verbatim text:

	 MIME-Version: 1.0

	 The presence of this header field is an assertion that the message
	 has been composed in compliance with this document.

	 Since it is possible that a future document might extend the message
	 format standard again, a formal BNF is given for the content of the
	 MIME-Version field:

	 version := "MIME-Version" ":" 1*DIGIT "." 1*DIGIT

	 Thus, future format specifiers, which might replace or extend "1.0",
	 are constrained to be two integer fields, separated by a period.	If
	 a message is received with a MIME-version value other than "1.0", it
	 cannot be assumed to conform with this specification.

	 Note that the MIME-Version header field is required at the top level
	 of a message. It is not required for each body part of a multipart
	 entity.	It is required for the embedded headers of a body of type
	 "message" if and only if the embedded message is itself claimed to be
	 MIME-conformant.

	 It is not possible to fully specify how a mail reader that conforms
	 with MIME as defined in this document should treat a message that
	 might arrive in the future with some value of MIME-Version other than
	 "1.0".	However, conformant software is encouraged to check the
	 version number and at least warn the user if an unrecognized MIME-
	 version is encountered.

	 It is also worth noting that version control for specific content-
	 types is not accomplished using the MIME-Version mechanism.	In
	 particular, some formats (such as application/postscript) have
	 version numbering conventions that are internal to the document
	 format.	Where such conventions exist, MIME does nothing to supersede
	 them.	Where no such conventions exist, a MIME type might use a
	 "version" parameter in the content-type field if necessary.

	 NOTE TO IMPLEMENTORS: All header fields defined in this document,
	 including MIME-Version, Content-type, etc., are subject to the
	 general syntactic rules for header fields specified in RFC 822.	In
	 particular, all can include comments, which means that the following
	 two MIME-Version fields are equivalent:

										MIME-Version: 1.0
										MIME-Version: 1.0 (Generated by GBD-killer 3.7)




Borenstein & Freed																							[Page 8]

RFC 1521													MIME										September 1993


4.		The Content-Type Header Field

	 The purpose of the Content-Type field is to describe the data
	 contained in the body fully enough that the receiving user agent can
	 pick an appropriate agent or mechanism to present the data to the
	 user, or otherwise deal with the data in an appropriate manner.

	 HISTORICAL NOTE: The Content-Type header field was first defined in
	 RFC 1049.	RFC 1049 Content-types used a simpler and less powerful
	 syntax, but one that is largely compatible with the mechanism given
	 here.

	 The Content-Type header field is used to specify the nature of the
	 data in the body of an entity, by giving type and subtype
	 identifiers, and by providing auxiliary information that may be
	 required for certain types.	After the type and subtype names, the
	 remainder of the header field is simply a set of parameters,
	 specified in an attribute/value notation.	The set of meaningful
	 parameters differs for the different types.	In particular, there are
	 NO globally-meaningful parameters that apply to all content-types.
	 Global mechanisms are best addressed, in the MIME model, by the
	 definition of additional Content-* header fields.	The ordering of
	 parameters is not significant.	Among the defined parameters is a
	 "charset" parameter by which the character set used in the body may
	 be declared. Comments are allowed in accordance with RFC 822 rules
	 for structured header fields.

	 In general, the top-level Content-Type is used to declare the general
	 type of data, while the subtype specifies a specific format for that
	 type of data.	Thus, a Content-Type of "image/xyz" is enough to tell
	 a user agent that the data is an image, even if the user agent has no
	 knowledge of the specific image format "xyz".	Such information can
	 be used, for example, to decide whether or not to show a user the raw
	 data from an unrecognized subtype -- such an action might be
	 reasonable for unrecognized subtypes of text, but not for
	 unrecognized subtypes of image or audio.	For this reason, registered
	 subtypes of audio, image, text, and video, should not contain
	 embedded information that is really of a different type.	Such
	 compound types should be represented using the "multipart" or
	 "application" types.

	 Parameters are modifiers of the content-subtype, and do not
	 fundamentally affect the requirements of the host system.	Although
	 most parameters make sense only with certain content-types, others
	 are "global" in the sense that they might apply to any subtype.	For
	 example, the "boundary" parameter makes sense only for the
	 "multipart" content-type, but the "charset" parameter might make
	 sense with several content-types.



Borenstein & Freed																							[Page 9]

RFC 1521													MIME										September 1993


	 An initial set of seven Content-Types is defined by this document.
	 This set of top-level names is intended to be substantially complete.
	 It is expected that additions to the larger set of supported types
	 can generally be accomplished by the creation of new subtypes of
	 these initial types.	In the future, more top-level types may be
	 defined only by an extension to this standard.	If another primary
	 type is to be used for any reason, it must be given a name starting
	 with "X-" to indicate its non-standard status and to avoid a
	 potential conflict with a future official name.

	 In the Augmented BNF notation of RFC 822, a Content-Type header field
	 value is defined as follows:

		 content	:=	 "Content-Type"	":"	type	"/"	subtype	*(";"
		 parameter)
							 ; case-insensitive matching of type and subtype

		 type :=					"application"		 / "audio"
							 / "image"					 / "message"
							 / "multipart"	/ "text"
							 / "video"					 / extension-token
							 ; All values case-insensitive

		 extension-token :=	x-token / iana-token

		 iana-token := <a publicly-defined extension token,
							 registered with IANA, as specified in
							 appendix E>

		 x-token := <The two characters "X-" or "x-" followed, with
								 no intervening white space, by any token>

		 subtype := token ; case-insensitive

		 parameter := attribute "=" value

		 attribute := token	 ; case-insensitive

		 value := token / quoted-string

		 token	:=	1*<any (ASCII) CHAR except SPACE, CTLs,
									 or tspecials>

		 tspecials :=	"(" / ")" / "<" / ">" / "@"
								/	"," / ";" / ":" / "\" / <">
								/	"/" / "[" / "]" / "?" / "="
							 ; Must be in quoted-string,
							 ; to use within parameter values



Borenstein & Freed																						 [Page 10]

RFC 1521													MIME										September 1993


	 Note that the definition of "tspecials" is the same as the RFC 822
	 definition of "specials" with the addition of the three characters
	 "/", "?", and "=", and the removal of ".".

	 Note also that a subtype specification is MANDATORY.	There are no
	 default subtypes.

	 The type, subtype, and parameter names are not case sensitive.	For
	 example, TEXT, Text, and TeXt are all equivalent.	Parameter values
	 are normally case sensitive, but certain parameters are interpreted
	 to be case-insensitive, depending on the intended use.	(For example,
	 multipart boundaries are case-sensitive, but the "access-type" for
	 message/External-body is not case-sensitive.)

	 Beyond this syntax, the only constraint on the definition of subtype
	 names is the desire that their uses must not conflict.	That is, it
	 would be undesirable to have two different communities using
	 "Content-Type: application/foobar" to mean two different things.	The
	 process of defining new content-subtypes, then, is not intended to be
	 a mechanism for imposing restrictions, but simply a mechanism for
	 publicizing the usages. There are, therefore, two acceptable
	 mechanisms for defining new Content-Type subtypes:

						1.	Private values (starting with "X-") may be
								defined bilaterally between two cooperating
								agents without outside registration or
								standardization.

						2.	New standard values must be documented,
								registered with, and approved by IANA, as
								described in Appendix E.	Where intended for
								public use, the formats they refer to must
								also be defined by a published specification,
								and possibly offered for standardization.

	 The seven standard initial predefined Content-Types are detailed in
	 the bulk of this document.	They are:

		text -- textual information.	The primary subtype,
				 "plain", indicates plain (unformatted) text.	No
				 special software is required to get the full
				 meaning of the text, aside from support for the
				 indicated character set.	Subtypes are to be used
				 for enriched text in forms where application
				 software may enhance the appearance of the text,
				 but such software must not be required in order to
				 get the general idea of the content.	Possible
				 subtypes thus include any readable word processor



Borenstein & Freed																						 [Page 11]

RFC 1521													MIME										September 1993


				 format.	A very simple and portable subtype,
				 richtext, was defined in RFC 1341, with a future
				 revision expected.

		multipart -- data consisting of multiple parts of
				 independent data types.	Four initial subtypes
				 are defined, including the primary "mixed"
				 subtype, "alternative" for representing the same
				 data in multiple formats, "parallel" for parts
				 intended to be viewed simultaneously, and "digest"
				 for multipart entities in which each part is of
				 type "message".

		message -- an encapsulated message.	A body of
				 Content-Type "message" is itself all or part of a
				 fully formatted RFC 822 conformant message which
				 may contain its own different Content-Type header
				 field.	The primary subtype is "rfc822".	The
				 "partial" subtype is defined for partial messages,
				 to permit the fragmented transmission of bodies
				 that are thought to be too large to be passed
				 through mail transport facilities.	Another
				 subtype, "External-body", is defined for
				 specifying large bodies by reference to an
				 external data source.

		image -- image data.	Image requires a display device
				 (such as a graphical display, a printer, or a FAX
				 machine) to view the information.	Initial
				 subtypes are defined for two widely-used image
				 formats, jpeg and gif.

		audio -- audio data, with initial subtype "basic".
				 Audio requires an audio output device (such as a
				 speaker or a telephone) to "display" the contents.

		video -- video data.	Video requires the capability to
				 display moving images, typically including
				 specialized hardware and software.	The initial
				 subtype is "mpeg".

		application -- some other kind of data, typically
				 either uninterpreted binary data or information to
				 be processed by a mail-based application.	The
				 primary subtype, "octet-stream", is to be used in
				 the case of uninterpreted binary data, in which
				 case the simplest recommended action is to offer
				 to write the information into a file for the user.



Borenstein & Freed																						 [Page 12]

RFC 1521													MIME										September 1993


				 An additional subtype, "PostScript", is defined
				 for transporting PostScript documents in bodies.
				 Other expected uses for "application" include
				 spreadsheets, data for mail-based scheduling
				 systems, and languages for "active"
				 (computational) email.	(Note that active email
				 and other application data may entail several
				 security considerations, which are discussed later
				 in this memo, particularly in the context of
				 application/PostScript.)

	 Default RFC 822 messages are typed by this protocol as plain text in
	 the US-ASCII character set, which can be explicitly specified as
	 "Content-type: text/plain; charset=us-ascii".	If no Content-Type is
	 specified, this default is assumed.	In the presence of a MIME-
	 Version header field, a receiving User Agent can also assume that
	 plain US-ASCII text was the sender's intent.	In the absence of a
	 MIME-Version specification, plain US-ASCII text must still be
	 assumed, but the sender's intent might have been otherwise.

			RATIONALE: In the absence of any Content-Type header field or
			MIME-Version header field, it is impossible to be certain that a
			message is actually text in the US-ASCII character set, since it
			might well be a message that, using the conventions that predate
			this document, includes text in another character set or non-
			textual data in a manner that cannot be automatically recognized
			(e.g., a uuencoded compressed UNIX tar file).	Although there is
			no fully acceptable alternative to treating such untyped messages
			as "text/plain; charset=us-ascii", implementors should remain
			aware that if a message lacks both the MIME-Version and the
			Content-Type header fields, it may in practice contain almost
			anything.

	 It should be noted that the list of Content-Type values given here
	 may be augmented in time, via the mechanisms described above, and
	 that the set of subtypes is expected to grow substantially.

	 When a mail reader encounters mail with an unknown Content-type
	 value, it should generally treat it as equivalent to
	 "application/octet-stream", as described later in this document.

5.		The Content-Transfer-Encoding Header Field

	 Many Content-Types which could usefully be transported via email are
	 represented, in their "natural" format, as 8-bit character or binary
	 data.	Such data cannot be transmitted over some transport protocols.
	 For example, RFC 821 restricts mail messages to 7-bit US-ASCII data
	 with lines no longer than 1000 characters.



Borenstein & Freed																						 [Page 13]

RFC 1521													MIME										September 1993


	 It is necessary, therefore, to define a standard mechanism for re-
	 encoding such data into a 7-bit short-line format.	This document
	 specifies that such encodings will be indicated by a new "Content-
	 Transfer-Encoding" header field.	The Content-Transfer-Encoding field
	 is used to indicate the type of transformation that has been used in
	 order to represent the body in an acceptable manner for transport.

	 Unlike Content-Types, a proliferation of Content-Transfer-Encoding
	 values is undesirable and unnecessary.	However, establishing only a
	 single Content-Transfer-Encoding mechanism does not seem possible.
	 There is a tradeoff between the desire for a compact and efficient
	 encoding of largely-binary data and the desire for a readable
	 encoding of data that is mostly, but not entirely, 7-bit data.	For
	 this reason, at least two encoding mechanisms are necessary: a
	 "readable" encoding and a "dense" encoding.

	 The Content-Transfer-Encoding field is designed to specify an
	 invertible mapping between the "native" representation of a type of
	 data and a representation that can be readily exchanged using 7 bit
	 mail transport protocols, such as those defined by RFC 821 (SMTP).
	 This field has not been defined by any previous standard. The field's
	 value is a single token specifying the type of encoding, as
	 enumerated below.	Formally:

	 encoding := "Content-Transfer-Encoding" ":" mechanism

	 mechanism :=		 "7bit"	;	case-insensitive
									/ "quoted-printable"
									/ "base64"
									/ "8bit"
									/ "binary"
									/ x-token

	 These values are not case sensitive.	That is, Base64 and BASE64 and
	 bAsE64 are all equivalent.	An encoding type of 7BIT requires that
	 the body is already in a seven-bit mail-ready representation.	This
	 is the default value -- that is, "Content-Transfer-Encoding: 7BIT" is
	 assumed if the Content-Transfer-Encoding header field is not present.

	 The values "8bit", "7bit", and "binary" all mean that NO encoding has
	 been performed. However, they are potentially useful as indications
	 of the kind of data contained in the object, and therefore of the
	 kind of encoding that might need to be performed for transmission in
	 a given transport system.	In particular:

			 "7bit" means that the data is all represented as short
						lines of US-ASCII data.




Borenstein & Freed																						 [Page 14]

RFC 1521													MIME										September 1993


			 "8bit" means that the lines are short, but there may be
						non-ASCII characters (octets with the high-order
						bit set).

			 "Binary" means that not only may non-ASCII characters
						be present, but also that the lines are not
						necessarily short enough for SMTP transport.

	 The difference between "8bit" (or any other conceivable bit-width
	 token) and the "binary" token is that "binary" does not require
	 adherence to any limits on line length or to the SMTP CRLF semantics,
	 while the bit-width tokens do require such adherence.	If the body
	 contains data in any bit-width other than 7-bit, the appropriate
	 bit-width Content-Transfer-Encoding token must be used (e.g., "8bit"
	 for unencoded 8 bit wide data).	If the body contains binary data,
	 the "binary" Content-Transfer-Encoding token must be used.

			NOTE: The distinction between the Content-Transfer-Encoding values
			of "binary", "8bit", etc.	may seem unimportant, in that all of
			them really mean "none" -- that is, there has been no encoding of
			the data for transport.	However, clear labeling will be of
			enormous value to gateways between future mail transport systems
			with differing capabilities in transporting data that do not meet
			the restrictions of RFC 821 transport.

			Mail transport for unencoded 8-bit data is defined in RFC-1426
			[RFC-1426].	As of the publication of this document, there are no
			standardized Internet mail transports for which it is legitimate
			to include unencoded binary data in mail bodies.	Thus there are
			no circumstances in which the "binary" Content-Transfer-Encoding
			is actually legal on the Internet.	However, in the event that
			binary mail transport becomes a reality in Internet mail, or when
			this document is used in conjunction with any other binary-capable
			transport mechanism, binary bodies should be labeled as such using
			this mechanism.

			NOTE: The five values defined for the Content-Transfer-Encoding
			field imply nothing about the Content-Type other than the
			algorithm by which it was encoded or the transport system
			requirements if unencoded.

	 Implementors may, if necessary, define new Content-Transfer-Encoding
	 values, but must use an x-token, which is a name prefixed by "X-" to
	 indicate its non-standard status, e.g., "Content-Transfer-Encoding:
	 x-my-new-encoding".	However, unlike Content-Types and subtypes, the
	 creation of new Content-Transfer-Encoding values is explicitly and
	 strongly discouraged, as it seems likely to hinder interoperability
	 with little potential benefit.	Their use is allowed only as the



Borenstein & Freed																						 [Page 15]

RFC 1521													MIME										September 1993


	 result of an agreement between cooperating user agents.

	 If a Content-Transfer-Encoding header field appears as part of a
	 message header, it applies to the entire body of that message.	If a
	 Content-Transfer-Encoding header field appears as part of a body
	 part's headers, it applies only to the body of that body part.	If an
	 entity is of type "multipart" or "message", the Content-Transfer-
	 Encoding is not permitted to have any value other than a bit width
	 (e.g., "7bit", "8bit", etc.) or "binary".

	 It should be noted that email is character-oriented, so that the
	 mechanisms described here are mechanisms for encoding arbitrary octet
	 streams, not bit streams.	If a bit stream is to be encoded via one
	 of these mechanisms, it must first be converted to an 8-bit byte
	 stream using the network standard bit order ("big-endian"), in which
	 the earlier bits in a stream become the higher-order bits in a byte.
	 A bit stream not ending at an 8-bit boundary must be padded with
	 zeroes.	This document provides a mechanism for noting the addition
	 of such padding in the case of the application Content-Type, which
	 has a "padding" parameter.

	 The encoding mechanisms defined here explicitly encode all data in
	 ASCII.	Thus, for example, suppose an entity has header fields such
	 as:

				Content-Type: text/plain; charset=ISO-8859-1
				Content-transfer-encoding: base64

	 This must be interpreted to mean that the body is a base64 ASCII
	 encoding of data that was originally in ISO-8859-1, and will be in
	 that character set again after decoding.

	 The following sections will define the two standard encoding
	 mechanisms.	The definition of new content-transfer-encodings is
	 explicitly discouraged and should only occur when absolutely
	 necessary.	All content-transfer-encoding namespace except that
	 beginning with "X-" is explicitly reserved to the IANA for future
	 use.	Private agreements about content-transfer-encodings are also
	 explicitly discouraged.

	 Certain Content-Transfer-Encoding values may only be used on certain
	 Content-Types.	In particular, it is expressly forbidden to use any
	 encodings other than "7bit", "8bit", or "binary" with any Content-
	 Type that recursively includes other Content-Type fields, notably the
	 "multipart" and "message" Content-Types.	All encodings that are
	 desired for bodies of type multipart or message must be done at the
	 innermost level, by encoding the actual body that needs to be
	 encoded.



Borenstein & Freed																						 [Page 16]

RFC 1521													MIME										September 1993


			NOTE ON ENCODING RESTRICTIONS: Though the prohibition against
			using content-transfer-encodings on data of type multipart or
			message may seem overly restrictive, it is necessary to prevent
			nested encodings, in which data are passed through an encoding
			algorithm multiple times, and must be decoded multiple times in
			order to be properly viewed.	Nested encodings add considerable
			complexity to user agents: aside from the obvious efficiency
			problems with such multiple encodings, they can obscure the basic
			structure of a message.	In particular, they can imply that
			several decoding operations are necessary simply to find out what
			types of objects a message contains.	Banning nested encodings may
			complicate the job of certain mail gateways, but this seems less
			of a problem than the effect of nested encodings on user agents.

			NOTE ON THE RELATIONSHIP BETWEEN CONTENT-TYPE AND CONTENT-
			TRANSFER-ENCODING: It may seem that the Content-Transfer-Encoding
			could be inferred from the characteristics of the Content-Type
			that is to be encoded, or, at the very least, that certain
			Content-Transfer-Encodings could be mandated for use with specific
			Content-Types. There are several reasons why this is not the case.
			First, given the varying types of transports used for mail, some
			encodings may be appropriate for some Content-Type/transport
			combinations and not for others.	(For example, in an 8-bit
			transport, no encoding would be required for text in certain
			character sets, while such encodings are clearly required for 7-
			bit SMTP.)	Second, certain Content-Types may require different
			types of transfer encoding under different circumstances. For
			example, many PostScript bodies might consist entirely of short
			lines of 7-bit data and hence require little or no encoding.
			Other PostScript bodies (especially those using Level 2
			PostScript's binary encoding mechanism) may only be reasonably
			represented using a binary transport encoding. Finally, since
			Content-Type is intended to be an open-ended specification
			mechanism, strict specification of an association between
			Content-Types and encodings effectively couples the specification
			of an application protocol with a specific lower-level transport.
			This is not desirable since the developers of a Content-Type
			should not have to be aware of all the transports in use and what
			their limitations are.

			NOTE ON TRANSLATING ENCODINGS: The quoted-printable and base64
			encodings are designed so that conversion between them is
			possible.	The only issue that arises in such a conversion is the
			handling of line breaks.	When converting from quoted-printable to
			base64 a line break must be converted into a CRLF sequence.
			Similarly, a CRLF sequence in base64 data must be converted to a
			quoted-printable line break, but ONLY when converting text data.




Borenstein & Freed																						 [Page 17]

RFC 1521													MIME										September 1993


			NOTE ON CANONICAL ENCODING MODEL: There was some confusion, in
			earlier drafts of this memo, regarding the model for when email
			data was to be converted to canonical form and encoded, and in
			particular how this process would affect the treatment of CRLFs,
			given that the representation of newlines varies greatly from
			system to system, and the relationship between content-transfer-
			encodings and character sets.	For this reason, a canonical model
			for encoding is presented as Appendix G.

5.1.	Quoted-Printable Content-Transfer-Encoding

	 The Quoted-Printable encoding is intended to represent data that
	 largely consists of octets that correspond to printable characters in
	 the ASCII character set.	It encodes the data in such a way that the
	 resulting octets are unlikely to be modified by mail transport.	If
	 the data being encoded are mostly ASCII text, the encoded form of the
	 data remains largely recognizable by humans.	A body which is
	 entirely ASCII may also be encoded in Quoted-Printable to ensure the
	 integrity of the data should the message pass through a character-
	 translating, and/or line-wrapping gateway.

	 In this encoding, octets are to be represented as determined by the
	 following rules:

			Rule #1: (General 8-bit representation) Any octet, except those
			indicating a line break according to the newline convention of the
			canonical (standard) form of the data being encoded, may be
			represented by an "=" followed by a two digit hexadecimal
			representation of the octet's value.	The digits of the
			hexadecimal alphabet, for this purpose, are "0123456789ABCDEF".
			Uppercase letters must be used when sending hexadecimal data,
			though a robust implementation may choose to recognize lowercase
			letters on receipt.	Thus, for example, the value 12 (ASCII form
			feed) can be represented by "=0C", and the value 61 (ASCII EQUAL
			SIGN) can be represented by "=3D".	Except when the following
			rules allow an alternative encoding, this rule is mandatory.

			Rule #2: (Literal representation) Octets with decimal values of 33
			through 60 inclusive, and 62 through 126, inclusive, MAY be
			represented as the ASCII characters which correspond to those
			octets (EXCLAMATION POINT through LESS THAN, and GREATER THAN
			through TILDE, respectively).

			Rule #3: (White Space): Octets with values of 9 and 32 MAY be
			represented as ASCII TAB (HT) and SPACE characters, respectively,
			but MUST NOT be so represented at the end of an encoded line. Any
			TAB (HT) or SPACE characters on an encoded line MUST thus be
			followed on that line by a printable character.	In particular, an



Borenstein & Freed																						 [Page 18]

RFC 1521													MIME										September 1993


			"=" at the end of an encoded line, indicating a soft line break
			(see rule #5) may follow one or more TAB (HT) or SPACE characters.
			It follows that an octet with value 9 or 32 appearing at the end
			of an encoded line must be represented according to Rule #1.	This
			rule is necessary because some MTAs (Message Transport Agents,
			programs which transport messages from one user to another, or
			perform a part of such transfers) are known to pad lines of text
			with SPACEs, and others are known to remove "white space"
			characters from the end of a line.	Therefore, when decoding a
			Quoted-Printable body, any trailing white space on a line must be
			deleted, as it will necessarily have been added by intermediate
			transport agents.

			Rule #4 (Line Breaks): A line break in a text body, independent of
			what its representation is following the canonical representation
			of the data being encoded, must be represented by a (RFC 822) line
			break, which is a CRLF sequence, in the Quoted-Printable encoding.
			Since the canonical representation of types other than text do not
			generally include the representation of line breaks, no hard line
			breaks (i.e.	line breaks that are intended to be meaningful and
			to be displayed to the user) should occur in the quoted-printable
			encoding of such types.	Of course, occurrences of "=0D", "=0A",
			"0A=0D" and "=0D=0A" will eventually be encountered.	In general,
			however, base64 is preferred over quoted-printable for binary
			data.

			Note that many implementations may elect to encode the local
			representation of various content types directly, as described in
			Appendix G.	In particular, this may apply to plain text material
			on systems that use newline conventions other than CRLF
			delimiters. Such an implementation is permissible, but the
			generation of line breaks must be generalized to account for the
			case where alternate representations of newline sequences are
			used.

			Rule #5 (Soft Line Breaks): The Quoted-Printable encoding REQUIRES
			that encoded lines be no more than 76 characters long. If longer
			lines are to be encoded with the Quoted-Printable encoding, 'soft'
			line breaks must be used. An equal sign as the last character on a
			encoded line indicates such a non-significant ('soft') line break
			in the encoded text. Thus if the "raw" form of the line is a
			single unencoded line that says:

					Now's the time for all folk to come to the aid of
					their country.

			This can be represented, in the Quoted-Printable encoding, as




Borenstein & Freed																						 [Page 19]

RFC 1521													MIME										September 1993


					Now's the time =
					for all folk to come=
					 to the aid of their country.

			This provides a mechanism with which long lines are encoded in
			such a way as to be restored by the user agent.	The 76 character
			limit does not count the trailing CRLF, but counts all other
			characters, including any equal signs.

	 Since the hyphen character ("-") is represented as itself in the
	 Quoted-Printable encoding, care must be taken, when encapsulating a
	 quoted-printable encoded body in a multipart entity, to ensure that
	 the encapsulation boundary does not appear anywhere in the encoded
	 body.	(A good strategy is to choose a boundary that includes a
	 character sequence such as "=_" which can never appear in a quoted-
	 printable body.	See the definition of multipart messages later in
	 this document.)

			NOTE: The quoted-printable encoding represents something of a
			compromise between readability and reliability in transport.
			Bodies encoded with the quoted-printable encoding will work
			reliably over most mail gateways, but may not work perfectly over
			a few gateways, notably those involving translation into EBCDIC.
			(In theory, an EBCDIC gateway could decode a quoted-printable body
			and re-encode it using base64, but such gateways do not yet
			exist.)	A higher level of confidence is offered by the base64
			Content-Transfer-Encoding.	A way to get reasonably reliable
			transport through EBCDIC gateways is to also quote the ASCII
			characters

						 !"#$@[\]^`{|}~

			according to rule #1.	See Appendix B for more information.

	 Because quoted-printable data is generally assumed to be line-
	 oriented, it is to be expected that the representation of the breaks
	 between the lines of quoted printable data may be altered in
	 transport, in the same manner that plain text mail has always been
	 altered in Internet mail when passing between systems with differing
	 newline conventions.	If such alterations are likely to constitute a
	 corruption of the data, it is probably more sensible to use the
	 base64 encoding rather than the quoted-printable encoding.

	 WARNING TO IMPLEMENTORS: If binary data are encoded in quoted-
	 printable, care must be taken to encode CR and LF characters as "=0D"
	 and "=0A", respectively.	In particular, a CRLF sequence in binary
	 data should be encoded as "=0D=0A".	Otherwise, if CRLF were
	 represented as a hard line break, it might be incorrectly decoded on



Borenstein & Freed																						 [Page 20]

RFC 1521													MIME										September 1993


	 platforms with different line break conventions.

	 For formalists, the syntax of quoted-printable data is described by
	 the following grammar:

	 quoted-printable := ([*(ptext / SPACE / TAB) ptext] ["="] CRLF)
				; Maximum line length of 76 characters excluding CRLF

	 ptext := octet /<any ASCII character except "=", SPACE, or TAB>
				; characters not listed as "mail-safe" in Appendix B
				; are also not recommended.

	 octet := "=" 2(DIGIT / "A" / "B" / "C" / "D" / "E" / "F")
				; octet must be used for characters > 127, =, SPACE, or TAB,
				; and is recommended for any characters not listed in
				; Appendix B as "mail-safe".

5.2.	Base64 Content-Transfer-Encoding

	 The Base64 Content-Transfer-Encoding is designed to represent
	 arbitrary sequences of octets in a form that need not be humanly
	 readable.	The encoding and decoding algorithms are simple, but the
	 encoded data are consistently only about 33 percent larger than the
	 unencoded data.	This encoding is virtually identical to the one used
	 in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.
	 The base64 encoding is adapted from RFC 1421, with one change: base64
	 eliminates the "*" mechanism for embedded clear text.

	 A 65-character subset of US-ASCII is used, enabling 6 bits to be
	 represented per printable character. (The extra 65th character, "=",
	 is used to signify a special processing function.)

			NOTE: This subset has the important property that it is
			represented identically in all versions of ISO 646, including US
			ASCII, and all characters in the subset are also represented
			identically in all versions of EBCDIC.	Other popular encodings,
			such as the encoding used by the uuencode utility and the base85
			encoding specified as part of Level 2 PostScript, do not share
			these properties, and thus do not fulfill the portability
			requirements a binary transport encoding for mail must meet.

	 The encoding process represents 24-bit groups of input bits as output
	 strings of 4 encoded characters. Proceeding from left to right, a
	 24-bit input group is formed by concatenating 3 8-bit input groups.
	 These 24 bits are then treated as 4 concatenated 6-bit groups, each
	 of which is translated into a single digit in the base64 alphabet.
	 When encoding a bit stream via the base64 encoding, the bit stream
	 must be presumed to be ordered with the most-significant-bit first.



Borenstein & Freed																						 [Page 21]

RFC 1521													MIME										September 1993


	 That is, the first bit in the stream will be the high-order bit in
	 the first byte, and the eighth bit will be the low-order bit in the
	 first byte, and so on.

	 Each 6-bit group is used as an index into an array of 64 printable
	 characters. The character referenced by the index is placed in the
	 output string. These characters, identified in Table 1, below, are
	 selected so as to be universally representable, and the set excludes
	 characters with particular significance to SMTP (e.g., ".", CR, LF)
	 and to the encapsulation boundaries defined in this document (e.g.,
	 "-").

														Table 1: The Base64 Alphabet

			Value Encoding	Value Encoding	Value Encoding	Value Encoding
					 0 A						17 R						34 i						51 z
					 1 B						18 S						35 j						52 0
					 2 C						19 T						36 k						53 1
					 3 D						20 U						37 l						54 2
					 4 E						21 V						38 m						55 3
					 5 F						22 W						39 n						56 4
					 6 G						23 X						40 o						57 5
					 7 H						24 Y						41 p						58 6
					 8 I						25 Z						42 q						59 7
					 9 J						26 a						43 r						60 8
					10 K						27 b						44 s						61 9
					11 L						28 c						45 t						62 +
					12 M						29 d						46 u						63 /
					13 N						30 e						47 v
					14 O						31 f						48 w				 (pad) =
					15 P						32 g						49 x
					16 Q						33 h						50 y

	 The output stream (encoded bytes) must be represented in lines of no
	 more than 76 characters each.	All line breaks or other characters
	 not found in Table 1 must be ignored by decoding software.	In base64
	 data, characters other than those in Table 1, line breaks, and other
	 white space probably indicate a transmission error, about which a
	 warning message or even a message rejection might be appropriate
	 under some circumstances.

	 Special processing is performed if fewer than 24 bits are available
	 at the end of the data being encoded.	A full encoding quantum is
	 always completed at the end of a body.	When fewer than 24 input bits
	 are available in an input group, zero bits are added (on the right)
	 to form an integral number of 6-bit groups.	Padding at the end of
	 the data is performed using the '=' character.	Since all base64
	 input is an integral number of octets, only the following cases can



Borenstein & Freed																						 [Page 22]

RFC 1521													MIME										September 1993


	 arise: (1) the final quantum of encoding input is an integral
	 multiple of 24 bits; here, the final unit of encoded output will be
	 an integral multiple of 4 characters with no "=" padding, (2) the
	 final quantum of encoding input is exactly 8 bits; here, the final
	 unit of encoded output will be two characters followed by two "="
	 padding characters, or (3) the final quantum of encoding input is
	 exactly 16 bits; here, the final unit of encoded output will be three
	 characters followed by one "=" padding character.

	 Because it is used only for padding at the end of the data, the
	 occurrence of any '=' characters may be taken as evidence that the
	 end of the data has been reached (without truncation in transit).	No
	 such assurance is possible, however, when the number of octets
	 transmitted was a multiple of three.

	 Any characters outside of the base64 alphabet are to be ignored in
	 base64-encoded data.	The same applies to any illegal sequence of
	 characters in the base64 encoding, such as "====="

	 Care must be taken to use the proper octets for line breaks if base64
	 encoding is applied directly to text material that has not been
	 converted to canonical form.	In particular, text line breaks must be
	 converted into CRLF sequences prior to base64 encoding. The important
	 thing to note is that this may be done directly by the encoder rather
	 than in a prior canonicalization step in some implementations.

			NOTE: There is no need to worry about quoting apparent
			encapsulation boundaries within base64-encoded parts of multipart
			entities because no hyphen characters are used in the base64
			encoding.

6.		Additional Content-Header Fields

6.1.	Optional Content-ID Header Field

	 In constructing a high-level user agent, it may be desirable to allow
	 one body to make reference to another.	Accordingly, bodies may be
	 labeled using the "Content-ID" header field, which is syntactically
	 identical to the "Message-ID" header field:

	 id :=	"Content-ID" ":" msg-id
	 Like the Message-ID values, Content-ID values must be generated to be
	 world-unique.

	 The Content-ID value may be used for uniquely identifying MIME
	 entities in several contexts, particularly for cacheing data
	 referenced by the message/external-body mechanism.	Although the
	 Content-ID header is generally optional, its use is mandatory in



Borenstein & Freed																						 [Page 23]

RFC 1521													MIME										September 1993


	 implementations which generate data of the optional MIME Content-type
	 "message/external-body".	That is, each message/external-body entity
	 must have a Content-ID field to permit cacheing of such data.

	 It is also worth noting that the Content-ID value has special
	 semantics in the case of the multipart/alternative content-type.
	 This is explained in the section of this document dealing with
	 multipart/alternative.

6.2.	Optional Content-Description Header Field

	 The ability to associate some descriptive information with a given
	 body is often desirable. For example, it may be useful to mark an
	 "image" body as "a picture of the Space Shuttle Endeavor."	Such text
	 may be placed in the Content-Description header field.

	 description := "Content-Description" ":" *text

	 The description is presumed to be given in the US-ASCII character
	 set, although the mechanism specified in [RFC-1522] may be used for
	 non-US-ASCII Content-Description values.

7.		The Predefined Content-Type Values

	 This document defines seven initial Content-Type values and an
	 extension mechanism for private or experimental types.	Further
	 standard types must be defined by new published specifications.	It
	 is expected that most innovation in new types of mail will take place
	 as subtypes of the seven types defined here.	The most essential
	 characteristics of the seven content-types are summarized in Appendix
	 F.

7.1	The Text Content-Type

	 The text Content-Type is intended for sending material which is
	 principally textual in form.	It is the default Content-Type.	A
	 "charset" parameter may be used to indicate the character set of the
	 body text for some text subtypes, notably including the primary
	 subtype, "text/plain", which indicates plain (unformatted) text.	The
	 default Content-Type for Internet mail is "text/plain; charset=us-
	 ascii".

	 Beyond plain text, there are many formats for representing what might
	 be known as "extended text" -- text with embedded formatting and
	 presentation information.	An interesting characteristic of many such
	 representations is that they are to some extent readable even without
	 the software that interprets them.	It is useful, then, to
	 distinguish them, at the highest level, from such unreadable data as



Borenstein & Freed																						 [Page 24]

RFC 1521													MIME										September 1993


	 images, audio, or text represented in an unreadable form.	In the
	 absence of appropriate interpretation software, it is reasonable to
	 show subtypes of text to the user, while it is not reasonable to do
	 so with most nontextual data.

	 Such formatted textual data should be represented using subtypes of
	 text.	Plausible subtypes of text are typically given by the common
	 name of the representation format, e.g., "text/richtext" [RFC-1341].

7.1.1.		 The charset parameter

	 A critical parameter that may be specified in the Content-Type field
	 for text/plain data is the character set.	This is specified with a
	 "charset" parameter, as in:

				Content-type: text/plain; charset=us-ascii

	 Unlike some other parameter values, the values of the charset
	 parameter are NOT case sensitive.	The default character set, which
	 must be assumed in the absence of a charset parameter, is US-ASCII.

	 The specification for any future subtypes of "text" must specify
	 whether or not they will also utilize a "charset" parameter, and may
	 possibly restrict its values as well.	When used with a particular
	 body, the semantics of the "charset" parameter should be identical to
	 those specified here for "text/plain", i.e., the body consists
	 entirely of characters in the given charset.	In particular, definers
	 of future text subtypes should pay close attention the the
	 implications of multibyte character sets for their subtype
	 definitions.

	 This RFC specifies the definition of the charset parameter for the
	 purposes of MIME to be a unique mapping of a byte stream to glyphs, a
	 mapping which does not require external profiling information.

	 An initial list of predefined character set names can be found at the
	 end of this section.	Additional character sets may be registered
	 with IANA, although the standardization of their use requires the
	 usual IESG [RFC-1340] review and approval.	Note that if the
	 specified character set includes 8-bit data, a Content-Transfer-
	 Encoding header field and a corresponding encoding on the data are
	 required in order to transmit the body via some mail transfer
	 protocols, such as SMTP.

	 The default character set, US-ASCII, has been the subject of some
	 confusion and ambiguity in the past.	Not only were there some
	 ambiguities in the definition, there have been wide variations in
	 practice.	In order to eliminate such ambiguity and variations in the



Borenstein & Freed																						 [Page 25]

RFC 1521													MIME										September 1993


	 future, it is strongly recommended that new user agents explicitly
	 specify a character set via the Content-Type header field.	"US-
	 ASCII" does not indicate an arbitrary seven-bit character code, but
	 specifies that the body uses character coding that uses the exact
	 correspondence of codes to characters specified in ASCII.	National
	 use variations of ISO 646 [ISO-646] are NOT ASCII and their use in
	 Internet mail is explicitly discouraged. The omission of the ISO 646
	 character set is deliberate in this regard.	The character set name
	 of "US-ASCII" explicitly refers to ANSI X3.4-1986 [US-ASCII] only.
	 The character set name "ASCII" is reserved and must not be used for
	 any purpose.

			NOTE: RFC 821 explicitly specifies "ASCII", and references an
			earlier version of the American Standard.	Insofar as one of the
			purposes of specifying a Content-Type and character set is to
			permit the receiver to unambiguously determine how the sender
			intended the coded message to be interpreted, assuming anything
			other than "strict ASCII" as the default would risk unintentional
			and incompatible changes to the semantics of messages now being
			transmitted.	This also implies that messages containing
			characters coded according to national variations on ISO 646, or
			using code-switching procedures (e.g., those of ISO 2022), as well
			as 8-bit or multiple octet character encodings MUST use an
			appropriate character set specification to be consistent with this
			specification.

	 The complete US-ASCII character set is listed in [US-ASCII].	Note
	 that the control characters including DEL (0-31, 127) have no defined
	 meaning apart from the combination CRLF (ASCII values 13 and 10)
	 indicating a new line.	Two of the characters have de facto meanings
	 in wide use: FF (12) often means "start subsequent text on the
	 beginning of a new page"; and TAB or HT (9) often (though not always)
	 means "move the cursor to the next available column after the current
	 position where the column number is a multiple of 8 (counting the
	 first column as column 0)." Apart from this, any use of the control
	 characters or DEL in a body must be part of a private agreement
	 between the sender and recipient.	Such private agreements are
	 discouraged and should be replaced by the other capabilities of this
	 document.

			NOTE: Beyond US-ASCII, an enormous proliferation of character sets
			is possible. It is the opinion of the IETF working group that a
			large number of character sets is NOT a good thing.	We would
			prefer to specify a single character set that can be used
			universally for representing all of the world's languages in
			electronic mail.	Unfortunately, existing practice in several
			communities seems to point to the continued use of multiple
			character sets in the near future.	For this reason, we define



Borenstein & Freed																						 [Page 26]

RFC 1521													MIME										September 1993


			names for a small number of character sets for which a strong
			constituent base exists.

	 The defined charset values are:

	 US-ASCII -- as defined in [US-ASCII].

				ISO-8859-X -- where "X" is to be replaced, as necessary, for the
						 parts of ISO-8859 [ISO-8859].	Note that the ISO 646
						 character sets have deliberately been omitted in favor of
						 their 8859 replacements, which are the designated character
						 sets for Internet mail.	As of the publication of this
						 document, the legitimate values for "X" are the digits 1
						 through 9.

	 The character sets specified above are the ones that were relatively
	 uncontroversial during the drafting of MIME.	This document does not
	 endorse the use of any particular character set other than US-ASCII,
	 and recognizes that the future evolution of world character sets
	 remains unclear.	It is expected that in the future, additional
	 character sets will be registered for use in MIME.

	 Note that the character set used, if anything other than US-ASCII,
	 must always be explicitly specified in the Content-Type field.

	 No other character set name may be used in Internet mail without the
	 publication of a formal specification and its registration with IANA,
	 or by private agreement, in which case the character set name must
	 begin with "X-".

	 Implementors are discouraged from defining new character sets for
	 mail use unless absolutely necessary.

	 The "charset" parameter has been defined primarily for the purpose of
	 textual data, and is described in this section for that reason.
	 However, it is conceivable that non-textual data might also wish to
	 specify a charset value for some purpose, in which case the same
	 syntax and values should be used.

	 In general, mail-sending software must always use the "lowest common
	 denominator" character set possible.	For example, if a body contains
	 only US-ASCII characters, it must be marked as being in the US-ASCII
	 character set, not ISO-8859-1, which, like all the ISO-8859 family of
	 character sets, is a superset of US-ASCII.	More generally, if a
	 widely-used character set is a subset of another character set, and a
	 body contains only characters in the widely-used subset, it must be
	 labeled as being in that subset.	This will increase the chances that
	 the recipient will be able to view the mail correctly.



Borenstein & Freed																						 [Page 27]

RFC 1521													MIME										September 1993


7.1.2.		 The Text/plain subtype

	 The primary subtype of text is "plain".	This indicates plain
	 (unformatted) text.	The default Content-Type for Internet mail,
	 "text/plain; charset=us-ascii", describes existing Internet practice.
	 That is, it is the type of body defined by RFC 822.

	 No other text subtype is defined by this document.

	 The formal grammar for the content-type header field for text is as
	 follows:

	 text-type := "text" "/" text-subtype [";" "charset" "=" charset]

	 text-subtype := "plain" / extension-token

	 charset := "us-ascii"/ "iso-8859-1"/ "iso-8859-2"/ "iso-8859-3"
					/ "iso-8859-4"/ "iso-8859-5"/ "iso-8859-6"/ "iso-8859-7"
					/ "iso-8859-8" / "iso-8859-9" / extension-token
										; case insensitive

7.2.	The Multipart Content-Type

	 In the case of multiple part entities, in which one or more different
	 sets of data are combined in a single body, a "multipart" Content-
	 Type field must appear in the entity's header. The body must then
	 contain one or more "body parts," each preceded by an encapsulation
	 boundary, and the last one followed by a closing boundary.	Each part
	 starts with an encapsulation boundary, and then contains a body part
	 consisting of header area, a blank line, and a body area.	Thus a
	 body part is similar to an RFC 822 message in syntax, but different
	 in meaning.

	 A body part is NOT to be interpreted as actually being an RFC 822
	 message.	To begin with, NO header fields are actually required in
	 body parts.	A body part that starts with a blank line, therefore, is
	 allowed and is a body part for which all default values are to be
	 assumed.	In such a case, the absence of a Content-Type header field
	 implies that the corresponding body is plain US-ASCII text.	The only
	 header fields that have defined meaning for body parts are those the
	 names of which begin with "Content-".	All other header fields are
	 generally to be ignored in body parts.	Although they should
	 generally be retained in mail processing, they may be discarded by
	 gateways if necessary.	Such other fields are permitted to appear in
	 body parts but must not be depended on.	"X-" fields may be created
	 for experimental or private purposes, with the recognition that the
	 information they contain may be lost at some gateways.




Borenstein & Freed																						 [Page 28]

RFC 1521													MIME										September 1993


			NOTE: The distinction between an RFC 822 message and a body part
			is subtle, but important. A gateway between Internet and X.400
			mail, for example, must be able to tell the difference between a
			body part that contains an image and a body part that contains an
			encapsulated message, the body of which is an image.	In order to
			represent the latter, the body part must have "Content-Type:
			message", and its body (after the blank line) must be the
			encapsulated message, with its own "Content-Type: image" header
			field.	The use of similar syntax facilitates the conversion of
			messages to body parts, and vice versa, but the distinction
			between the two must be understood by implementors.	(For the
			special case in which all parts actually are messages, a "digest"
			subtype is also defined.)

	 As stated previously, each body part is preceded by an encapsulation
	 boundary.	The encapsulation boundary MUST NOT appear inside any of
	 the encapsulated parts.	Thus, it is crucial that the composing agent
	 be able to choose and specify the unique boundary that will separate
	 the parts.

	 All present and future subtypes of the "multipart" type must use an
	 identical syntax.	Subtypes may differ in their semantics, and may
	 impose additional restrictions on syntax, but must conform to the
	 required syntax for the multipart type.	This requirement ensures
	 that all conformant user agents will at least be able to recognize
	 and separate the parts of any multipart entity, even of an
	 unrecognized subtype.

	 As stated in the definition of the Content-Transfer-Encoding field,
	 no encoding other than "7bit", "8bit", or "binary" is permitted for
	 entities of type "multipart".	The multipart delimiters and header
	 fields are always represented as 7-bit ASCII in any case (though the
	 header fields may encode non-ASCII header text as per [RFC-1522]),
	 and data within the body parts can be encoded on a part-by-part
	 basis, with Content-Transfer-Encoding fields for each appropriate
	 body part.

	 Mail gateways, relays, and other mail handling agents are commonly
	 known to alter the top-level header of an RFC 822 message.	In
	 particular, they frequently add, remove, or reorder header fields.
	 Such alterations are explicitly forbidden for the body part headers
	 embedded in the bodies of messages of type "multipart."

7.2.1.		 Multipart:	The common syntax

	 All subtypes of "multipart" share a common syntax, defined in this
	 section.	A simple example of a multipart message also appears in
	 this section.	An example of a more complex multipart message is



Borenstein & Freed																						 [Page 29]

RFC 1521													MIME										September 1993


	 given in Appendix C.

	 The Content-Type field for multipart entities requires one parameter,
	 "boundary", which is used to specify the encapsulation boundary.	The
	 encapsulation boundary is defined as a line consisting entirely of
	 two hyphen characters ("-", decimal code 45) followed by the boundary
	 parameter value from the Content-Type header field.

			NOTE: The hyphens are for rough compatibility with the earlier RFC
			934 method of message encapsulation, and for ease of searching for
			the boundaries in some implementations. However, it should be
			noted that multipart messages are NOT completely compatible with
			RFC 934 encapsulations; in particular, they do not obey RFC 934
			quoting conventions for embedded lines that begin with hyphens.
			This mechanism was chosen over the RFC 934 mechanism because the
			latter causes lines to grow with each level of quoting.	The
			combination of this growth with the fact that SMTP implementations
			sometimes wrap long lines made the RFC 934 mechanism unsuitable
			for use in the event that deeply-nested multipart structuring is
			ever desired.

	 WARNING TO IMPLEMENTORS: The grammar for parameters on the Content-
	 type field is such that it is often necessary to enclose the
	 boundaries in quotes on the Content-type line.	This is not always
	 necessary, but never hurts.	Implementors should be sure to study the
	 grammar carefully in order to avoid producing illegal Content-type
	 fields. Thus, a typical multipart Content-Type header field might
	 look like this:

								 Content-Type: multipart/mixed;
											boundary=gc0p4Jq0M2Yt08jU534c0p

	 But the following is illegal:

								 Content-Type: multipart/mixed;
											boundary=gc0p4Jq0M:2Yt08jU534c0p

	 (because of the colon) and must instead be represented as

								 Content-Type: multipart/mixed;
											boundary="gc0p4Jq0M:2Yt08jU534c0p"

	 This indicates that the entity consists of several parts, each itself
	 with a structure that is syntactically identical to an RFC 822
	 message, except that the header area might be completely empty, and
	 that the parts are each preceded by the line

								 --gc0p4Jq0M:2Yt08jU534c0p



Borenstein & Freed																						 [Page 30]

RFC 1521													MIME										September 1993


	 Note that the encapsulation boundary must occur at the beginning of a
	 line, i.e., following a CRLF, and that the initial CRLF is considered
	 to be attached to the encapsulation boundary rather than part of the
	 preceding part.	The boundary must be followed immediately either by
	 another CRLF and the header fields for the next part, or by two
	 CRLFs, in which case there are no header fields for the next part
	 (and it is therefore assumed to be of Content-Type text/plain).

			NOTE: The CRLF preceding the encapsulation line is conceptually
			attached to the boundary so that it is possible to have a part
			that does not end with a CRLF (line break). Body parts that must
			be considered to end with line breaks, therefore, must have two
			CRLFs preceding the encapsulation line, the first of which is part
			of the preceding body part, and the second of which is part of the
			encapsulation boundary.

	 Encapsulation boundaries must not appear within the encapsulations,
	 and must be no longer than 70 characters, not counting the two
	 leading hyphens.

	 The encapsulation boundary following the last body part is a
	 distinguished delimiter that indicates that no further body parts
	 will follow.	Such a delimiter is identical to the previous
	 delimiters, with the addition of two more hyphens at the end of the
	 line:

								 --gc0p4Jq0M2Yt08jU534c0p--

	 There appears to be room for additional information prior to the
	 first encapsulation boundary and following the final boundary.	These
	 areas should generally be left blank, and implementations must ignore
	 anything that appears before the first boundary or after the last
	 one.

			NOTE: These "preamble" and "epilogue" areas are generally not used
			because of the lack of proper typing of these parts and the lack
			of clear semantics for handling these areas at gateways,
			particularly X.400 gateways.	However, rather than leaving the
			preamble area blank, many MIME implementations have found this to
			be a convenient place to insert an explanatory note for recipients
			who read the message with pre-MIME software, since such notes will
			be ignored by MIME-compliant software.

			NOTE: Because encapsulation boundaries must not appear in the body
			parts being encapsulated, a user agent must exercise care to
			choose a unique boundary.	The boundary in the example above could
			have been the result of an algorithm designed to produce
			boundaries with a very low probability of already existing in the



Borenstein & Freed																						 [Page 31]

RFC 1521													MIME										September 1993


			data to be encapsulated without having to prescan the data.
			Alternate algorithms might result in more 'readable' boundaries
			for a recipient with an old user agent, but would require more
			attention to the possibility that the boundary might appear in the
			encapsulated part.	The simplest boundary possible is something
			like "---", with a closing boundary of "-----".

	 As a very simple example, the following multipart message has two
	 parts, both of them plain text, one of them explicitly typed and one
	 of them implicitly typed:

			From: Nathaniel Borenstein <nsb@bellcore.com>
			To:	Ned Freed <ned@innosoft.com>
			Subject: Sample message
			MIME-Version: 1.0
			Content-type: multipart/mixed; boundary="simple
			boundary"

			This is the preamble.	It is to be ignored, though it
			is a handy place for mail composers to include an
			explanatory note to non-MIME conformant readers.
			--simple boundary

			This is implicitly typed plain ASCII text.
			It does NOT end with a linebreak.
			--simple boundary
			Content-type: text/plain; charset=us-ascii

			This is explicitly typed plain ASCII text.
			It DOES end with a linebreak.

			--simple boundary--
			This is the epilogue.	It is also to be ignored.

	 The use of a Content-Type of multipart in a body part within another
	 multipart entity is explicitly allowed.	In such cases, for obvious
	 reasons, care must be taken to ensure that each nested multipart
	 entity must use a different boundary delimiter. See Appendix C for an
	 example of nested multipart entities.

	 The use of the multipart Content-Type with only a single body part
	 may be useful in certain contexts, and is explicitly permitted.

	 The only mandatory parameter for the multipart Content-Type is the
	 boundary parameter, which consists of 1 to 70 characters from a set
	 of characters known to be very robust through email gateways, and NOT
	 ending with white space.	(If a boundary appears to end with white
	 space, the white space must be presumed to have been added by a



Borenstein & Freed																						 [Page 32]

RFC 1521													MIME										September 1993


	 gateway, and must be deleted.)	It is formally specified by the
	 following BNF:

	 boundary := 0*69<bchars> bcharsnospace

	 bchars := bcharsnospace / " "

	 bcharsnospace :=		DIGIT / ALPHA / "'" / "(" / ")" / "+" /"_"
								 / "," / "-" / "." / "/" / ":" / "=" / "?"

	 Overall, the body of a multipart entity may be specified	as
	 follows:

	 multipart-body := preamble 1*encapsulation
									close-delimiter epilogue

	 encapsulation := delimiter body-part CRLF

	 delimiter := "--" boundary CRLF ; taken from Content-Type field.
																	 ; There must be no space
																	 ; between "--" and boundary.

	 close-delimiter := "--" boundary "--" CRLF ; Again, no space
	 by "--",

	 preamble := discard-text	 ;	to	be	ignored upon receipt.

	 epilogue := discard-text	 ;	to	be	ignored upon receipt.

	 discard-text := *(*text CRLF)

	 body-part := <"message" as defined in RFC 822,
						 with all header fields optional, and with the
						 specified delimiter not occurring anywhere in
						 the message body, either on a line by itself
						 or as a substring anywhere.	Note that the
						 semantics of a part differ from the semantics
						 of a message, as described in the text.>

			NOTE: In certain transport enclaves, RFC 822 restrictions such as
			the one that limits bodies to printable ASCII characters may not
			be in force.	(That is, the transport domains may resemble
			standard Internet mail transport as specified in RFC821 and
			assumed by RFC822, but without certain restrictions.)	The
			relaxation of these restrictions should be construed as locally
			extending the definition of bodies, for example to include octets
			outside of the ASCII range, as long as these extensions are
			supported by the transport and adequately documented in the



Borenstein & Freed																						 [Page 33]

RFC 1521													MIME										September 1993


			Content-Transfer-Encoding header field. However, in no event are
			headers (either message headers or body-part headers) allowed to
			contain anything other than ASCII characters.

			NOTE: Conspicuously missing from the multipart type is a notion of
			structured, related body parts.	In general, it seems premature to
			try to standardize interpart structure yet.	It is recommended
			that those wishing to provide a more structured or integrated
			multipart messaging facility should define a subtype of multipart
			that is syntactically identical, but that always expects the
			inclusion of a distinguished part that can be used to specify the
			structure and integration of the other parts, probably referring
			to them by their Content-ID field.	If this approach is used,
			other implementations will not recognize the new subtype, but will
			treat it as the primary subtype (multipart/mixed) and will thus be
			able to show the user the parts that are recognized.

7.2.2.		 The Multipart/mixed (primary) subtype

	 The primary subtype for multipart, "mixed", is intended for use when
	 the body parts are independent and need to be bundled in a particular
	 order.	Any multipart subtypes that an implementation does not
	 recognize must be treated as being of subtype "mixed".

7.2.3.		 The Multipart/alternative subtype

	 The multipart/alternative type is syntactically identical to
	 multipart/mixed, but the semantics are different.	In particular,
	 each of the parts is an "alternative" version of the same
	 information.

	 Systems should recognize that the content of the various parts are
	 interchangeable.	Systems should choose the "best" type based on the
	 local environment and preferences, in some cases even through user
	 interaction.	As with multipart/mixed, the order of body parts is
	 significant.	In this case, the alternatives appear in an order of
	 increasing faithfulness to the original content. In general, the best
	 choice is the LAST part of a type supported by the recipient system's
	 local environment.

	 Multipart/alternative may be used, for example, to send mail in a
	 fancy text format in such a way that it can easily be displayed
	 anywhere:








Borenstein & Freed																						 [Page 34]

RFC 1521													MIME										September 1993


	 From:	Nathaniel Borenstein <nsb@bellcore.com>
	 To: Ned Freed <ned@innosoft.com>
	 Subject: Formatted text mail
	 MIME-Version: 1.0
	 Content-Type: multipart/alternative; boundary=boundary42

	 --boundary42

	 Content-Type: text/plain; charset=us-ascii

			...plain text version of message goes here....
	 --boundary42
	 Content-Type: text/richtext

			.... RFC 1341 richtext version of same message goes here ...
	 --boundary42
	 Content-Type: text/x-whatever

			.... fanciest formatted version of same	message	goes	here
			...
	 --boundary42--

	 In this example, users whose mail system understood the "text/x-
	 whatever" format would see only the fancy version, while other users
	 would see only the richtext or plain text version, depending on the
	 capabilities of their system.

	 In general, user agents that compose multipart/alternative entities
	 must place the body parts in increasing order of preference, that is,
	 with the preferred format last.	For fancy text, the sending user
	 agent should put the plainest format first and the richest format
	 last.	Receiving user agents should pick and display the last format
	 they are capable of displaying.	In the case where one of the
	 alternatives is itself of type "multipart" and contains unrecognized
	 sub-parts, the user agent may choose either to show that alternative,
	 an earlier alternative, or both.

			NOTE: From an implementor's perspective, it might seem more
			sensible to reverse this ordering, and have the plainest
			alternative last.	However, placing the plainest alternative first
			is the friendliest possible option when multipart/alternative
			entities are viewed using a non-MIME-conformant mail reader.
			While this approach does impose some burden on conformant mail
			readers, interoperability with older mail readers was deemed to be
			more important in this case.

	 It may be the case that some user agents, if they can recognize more
	 than one of the formats, will prefer to offer the user the choice of



Borenstein & Freed																						 [Page 35]

RFC 1521													MIME										September 1993


	 which format to view.	This makes sense, for example, if mail
	 includes both a nicely-formatted image version and an easily-edited
	 text version.	What is most critical, however, is that the user not
	 automatically be shown multiple versions of the same data.	Either
	 the user should be shown the last recognized version or should be
	 given the choice.

	 NOTE ON THE SEMANTICS OF CONTENT-ID IN MULTIPART/ALTERNATIVE: Each
	 part of a multipart/alternative entity represents the same data, but
	 the mappings between the two are not necessarily without information
	 loss.	For example, information is lost when translating ODA to
	 PostScript or plain text.	It is recommended that each part should
	 have a different Content-ID value in the case where the information
	 content of the two parts is not identical.	However, where the
	 information content is identical -- for example, where several parts
	 of type "application/external- body" specify alternate ways to access
	 the identical data -- the same Content-ID field value should be used,
	 to optimize any cacheing mechanisms that might be present on the
	 recipient's end.	However, it is recommended that the Content-ID
	 values used by the parts should not be the same Content-ID value that
	 describes the multipart/alternative as a whole, if there is any such
	 Content-ID field.	That is, one Content-ID value will refer to the
	 multipart/alternative entity, while one or more other Content-ID
	 values will refer to the parts inside it.

7.2.4.		 The Multipart/digest subtype

	 This document defines a "digest" subtype of the multipart Content-
	 Type.	This type is syntactically identical to multipart/mixed, but
	 the semantics are different.	In particular, in a digest, the default
	 Content-Type value for a body part is changed from "text/plain" to
	 "message/rfc822".	This is done to allow a more readable digest
	 format that is largely compatible (except for the quoting convention)
	 with RFC 934.

















Borenstein & Freed																						 [Page 36]

RFC 1521													MIME										September 1993


	 A digest in this format might, then, look something like this:

	 From: Moderator-Address
	 To: Recipient-List
	 MIME-Version: 1.0
	 Subject:	Internet Digest, volume 42
	 Content-Type: multipart/digest;
				boundary="---- next message ----"

	 ------ next message ----

	 From: someone-else
	 Subject: my opinion

			...body goes here ...

	 ------ next message ----

	 From: someone-else-again
	 Subject: my different opinion

			... another body goes here...

	 ------ next message ------

7.2.5.		 The Multipart/parallel subtype

	 This document defines a "parallel" subtype of the multipart Content-
	 Type.	This type is syntactically identical to multipart/mixed, but
	 the semantics are different.	In particular, in a parallel entity,
	 the order of body parts is not significant.

	 A common presentation of this type is to display all of the parts
	 simultaneously on hardware and software that are capable of doing so.
	 However, composing agents should be aware that many mail readers will
	 lack this capability and will show the parts serially in any event.

7.2.6.		 Other Multipart subtypes

	 Other multipart subtypes are expected in the future.	MIME
	 implementations must in general treat unrecognized subtypes of
	 multipart as being equivalent to "multipart/mixed".

	 The formal grammar for content-type header fields for multipart data
	 is given by:

	 multipart-type := "multipart" "/" multipart-subtype
									";" "boundary" "=" boundary



Borenstein & Freed																						 [Page 37]

RFC 1521													MIME										September 1993


	 multipart-subtype := "mixed" / "parallel" / "digest"
									/ "alternative" / extension-token

7.3.	The Message Content-Type

	 It is frequently desirable, in sending mail, to encapsulate another
	 mail message. For this common operation, a special Content-Type,
	 "message", is defined.	The primary subtype, message/rfc822, has no
	 required parameters in the Content-Type field.	Additional subtypes,
	 "partial" and "External-body", do have required parameters.	These
	 subtypes are explained below.

			NOTE: It has been suggested that subtypes of message might be
			defined for forwarded or rejected messages.	However, forwarded
			and rejected messages can be handled as multipart messages in
			which the first part contains any control or descriptive
			information, and a second part, of type message/rfc822, is the
			forwarded or rejected message.	Composing rejection and forwarding
			messages in this manner will preserve the type information on the
			original message and allow it to be correctly presented to the
			recipient, and hence is strongly encouraged.

	 As stated in the definition of the Content-Transfer-Encoding field,
	 no encoding other than "7bit", "8bit", or "binary" is permitted for
	 messages or parts of type "message".	Even stronger restrictions
	 apply to the subtypes "message/partial" and "message/external-body",
	 as specified below.	The message header fields are always US-ASCII in
	 any case, and data within the body can still be encoded, in which
	 case the Content-Transfer-Encoding header field in the encapsulated
	 message will reflect this.	Non-ASCII text in the headers of an
	 encapsulated message can be specified using the mechanisms described
	 in [RFC-1522].

	 Mail gateways, relays, and other mail handling agents are commonly
	 known to alter the top-level header of an RFC 822 message.	In
	 particular, they frequently add, remove, or reorder header fields.
	 Such alterations are explicitly forbidden for the encapsulated
	 headers embedded in the bodies of messages of type "message."

7.3.1.		 The Message/rfc822 (primary) subtype

	 A Content-Type of "message/rfc822" indicates that the body contains
	 an encapsulated message, with the syntax of an RFC 822 message.
	 However, unlike top-level RFC 822 messages, it is not required that
	 each message/rfc822 body must include a "From", "Subject", and at
	 least one destination header.

	 It should be noted that, despite the use of the numbers "822", a



Borenstein & Freed																						 [Page 38]

RFC 1521													MIME										September 1993


	 message/rfc822 entity can include enhanced information as defined in
	 this document.	In other words, a message/rfc822 message may be a
	 MIME message.

7.3.2.		 The Message/Partial subtype

	 A subtype of message, "partial", is defined in order to allow large
	 objects to be delivered as several separate pieces of mail and
	 automatically reassembled by the receiving user agent.	(The concept
	 is similar to IP fragmentation/reassembly in the basic Internet
	 Protocols.)	This mechanism can be used when intermediate transport
	 agents limit the size of individual messages that can be sent.
	 Content-Type "message/partial" thus indicates that the body contains
	 a fragment of a larger message.

	 Three parameters must be specified in the Content-Type field of type
	 message/partial: The first, "id", is a unique identifier, as close to
	 a world-unique identifier as possible, to be used to match the parts
	 together.	(In general, the identifier is essentially a message-id;
	 if placed in double quotes, it can be any message-id, in accordance
	 with the BNF for "parameter" given earlier in this specification.)
	 The second, "number", an integer, is the part number, which indicates
	 where this part fits into the sequence of fragments.	The third,
	 "total", another integer, is the total number of parts. This third
	 subfield is required on the final part, and is optional (though
	 encouraged) on the earlier parts.	Note also that these parameters
	 may be given in any order.

	 Thus, part 2 of a 3-part message may have either of the following
	 header fields:

								Content-Type: Message/Partial;
										 number=2; total=3;
										 id="oc=jpbe0M2Yt4s@thumper.bellcore.com"

								Content-Type: Message/Partial;
										 id="oc=jpbe0M2Yt4s@thumper.bellcore.com";
										 number=2

	 But part 3 MUST specify the total number of parts:

								Content-Type: Message/Partial;
										 number=3; total=3;
										 id="oc=jpbe0M2Yt4s@thumper.bellcore.com"

	 Note that part numbering begins with 1, not 0.

	 When the parts of a message broken up in this manner are put



Borenstein & Freed																						 [Page 39]

RFC 1521													MIME										September 1993


	 together, the result is a complete MIME entity, which may have its
	 own Content-Type header field, and thus may contain any other data
	 type.

	 Message fragmentation and reassembly: The semantics of a reassembled
	 partial message must be those of the "inner" message, rather than of
	 a message containing the inner message.	This makes it possible, for
	 example, to send a large audio message as several partial messages,
	 and still have it appear to the recipient as a simple audio message
	 rather than as an encapsulated message containing an audio message.
	 That is, the encapsulation of the message is considered to be
	 "transparent".

	 When generating and reassembling the parts of a message/partial
	 message, the headers of the encapsulated message must be merged with
	 the headers of the enclosing entities.	In this process the following
	 rules must be observed:

			(1) All of the header fields from the initial enclosing entity
			(part one), except those that start with "Content-" and the
			specific header fields "Message-ID", "Encrypted", and "MIME-
			Version", must be copied, in order, to the new message.

			(2) Only those header fields in the enclosed message which start
			with "Content-" and "Message-ID", "Encrypted", and "MIME-Version"
			must be appended, in order, to the header fields of the new
			message.	Any header fields in the enclosed message which do not
			start with "Content-" (except for "Message-ID", "Encrypted", and
			"MIME-Version") will be ignored.

			(3) All of the header fields from the second and any subsequent
			messages will be ignored.

	 For example, if an audio message is broken into two parts, the first
	 part might look something like this:

			X-Weird-Header-1: Foo
			From: Bill@host.com
			To: joe@otherhost.com
			Subject: Audio mail
			Message-ID: <id1@host.com>
			MIME-Version: 1.0
			Content-type: message/partial;
					 id="ABC@host.com";
					 number=1; total=2

			X-Weird-Header-1: Bar
			X-Weird-Header-2: Hello



Borenstein & Freed																						 [Page 40]

RFC 1521													MIME										September 1993


			Message-ID: <anotherid@foo.com>
			MIME-Version: 1.0
			Content-type: audio/basic
			Content-transfer-encoding: base64

				 ... first half of encoded audio data goes here...

	 and the second half might look something like this:

			From: Bill@host.com
			To: joe@otherhost.com
			Subject: Audio mail
			MIME-Version: 1.0
			Message-ID: <id2@host.com>
			Content-type: message/partial;
					 id="ABC@host.com"; number=2; total=2

				 ... second half of encoded audio data goes here...

	 Then, when the fragmented message is reassembled, the resulting
	 message to be displayed to the user should look something like this:

			X-Weird-Header-1: Foo
			From: Bill@host.com
			To: joe@otherhost.com
			Subject: Audio mail
			Message-ID: <anotherid@foo.com>
			MIME-Version: 1.0
			Content-type: audio/basic
			Content-transfer-encoding: base64

				 ... first half of encoded audio data goes here...
				 ... second half of encoded audio data goes here...

	 Note on encoding of MIME entities encapsulated inside message/partial
	 entities: Because data of type "message" may never be encoded in
	 base64 or quoted-printable, a problem might arise if message/partial
	 entities are constructed in an environment that supports binary or
	 8-bit transport.	The problem is that the binary data would be split
	 into multiple message/partial objects, each of them requiring binary
	 transport.	If such objects were encountered at a gateway into a 7-
	 bit transport environment, there would be no way to properly encode
	 them for the 7-bit world, aside from waiting for all of the parts,
	 reassembling the message, and then encoding the reassembled data in
	 base64 or quoted-printable.	Since it is possible that different
	 parts might go through different gateways, even this is not an
	 acceptable solution.	For this reason, it is specified that MIME
	 entities of type message/partial must always have a content-



Borenstein & Freed																						 [Page 41]

RFC 1521													MIME										September 1993


	 transfer-encoding of 7-bit (the default).	In particular, even in
	 environments that support binary or 8-bit transport, the use of a
	 content-transfer-encoding of "8bit" or "binary" is explicitly
	 prohibited for entities of type message/partial.

	 It should be noted that, because some message transfer agents may
	 choose to automatically fragment large messages, and because such
	 agents may use different fragmentation thresholds, it is possible
	 that the pieces of a partial message, upon reassembly, may prove
	 themselves to comprise a partial message.	This is explicitly
	 permitted.

	 It should also be noted that the inclusion of a "References" field in
	 the headers of the second and subsequent pieces of a fragmented
	 message that references the Message-Id on the previous piece may be
	 of benefit to mail readers that understand and track references.
	 However, the generation of such "References" fields is entirely
	 optional.

	 Finally, it should be noted that the "Encrypted" header field has
	 been made obsolete by Privacy Enhanced Messaging (PEM), but the rules
	 above are believed to describe the correct way to treat it if it is
	 encountered in the context of conversion to and from message/partial
	 fragments.

7.3.3.		 The Message/External-Body subtype

	 The external-body subtype indicates that the actual body data are not
	 included, but merely referenced.	In this case, the parameters
	 describe a mechanism for accessing the external data.

	 When an entity is of type "message/external-body", it consists of a
	 header, two consecutive CRLFs, and the message header for the
	 encapsulated message.	If another pair of consecutive CRLFs appears,
	 this of course ends the message header for the encapsulated message.
	 However, since the encapsulated message's body is itself external, it
	 does NOT appear in the area that follows.	For example, consider the
	 following message:

			Content-type: message/external-body; access-
			type=local-file;

					 name="/u/nsb/Me.gif"

			Content-type:	image/gif
			Content-ID: <id42@guppylake.bellcore.com>
			Content-Transfer-Encoding: binary




Borenstein & Freed																						 [Page 42]

RFC 1521													MIME										September 1993


			THIS IS NOT REALLY THE BODY!

	 The area at the end, which might be called the "phantom body", is
	 ignored for most external-body messages.	However, it may be used to
	 contain auxiliary information for some such messages, as indeed it is
	 when the access-type is "mail-server".	Of the access-types defined
	 by this document, the phantom body is used only when the access-type
	 is "mail-server".	In all other cases, the phantom body is ignored.

	 The only always-mandatory parameter for message/external-body is
	 "access-type"; all of the other parameters may be mandatory or
	 optional depending on the value of access-type.

			ACCESS-TYPE -- A case-insensitive word, indicating the supported
			access mechanism by which the file or data may be obtained.
			Values include, but are not limited to, "FTP", "ANON-FTP", "TFTP",
			"AFS", "LOCAL-FILE", and "MAIL-SERVER".	Future values, except for
			experimental values beginning with "X-" must be registered with
			IANA, as described in Appendix E .

	 In addition, the following three parameters are optional for ALL
	 access-types:

			EXPIRATION -- The date (in the RFC 822 "date-time" syntax, as
			extended by RFC 1123 to permit 4 digits in the year field) after
			which the existence of the external data is not guaranteed.

			SIZE -- The size (in octets) of the data.	The intent of this
			parameter is to help the recipient decide whether or not to expend
			the necessary resources to retrieve the external data.	Note that
			this describes the size of the data in its canonical form, that
			is, before any Content- Transfer-Encoding has been applied or
			after the data have been decoded.

			PERMISSION -- A case-insensitive field that indicates whether or
			not it is expected that clients might also attempt to overwrite
			the data.	By default, or if permission is "read", the assumption
			is that they are not, and that if the data is retrieved once, it
			is never needed again.	If PERMISSION is "read-write", this
			assumption is invalid, and any local copy must be considered no
			more than a cache.	"Read" and "Read-write" are the only defined
			values of permission.

	 The precise semantics of the access-types defined here are described
	 in the sections that follow.

	 The encapsulated headers in ALL message/external-body entities MUST
	 include a Content-ID header field to give a unique identifier by



Borenstein & Freed																						 [Page 43]

RFC 1521													MIME										September 1993


	 which to reference the data.	This identifier may be used for
	 cacheing mechanisms, and for recognizing the receipt of the data when
	 the access-type is "mail-server".

	 Note that, as specified here, the tokens that describe external-body
	 data, such as file names and mail server commands, are required to be
	 in the US-ASCII character set.	If this proves problematic in
	 practice, a new mechanism may be required as a future extension to
	 MIME, either as newly defined access-types for message/external-body
	 or by some other mechanism.

	 As with message/partial, it is specified that MIME entities of type
	 message/external-body must always have a content-transfer-encoding of
	 7-bit (the default).	In particular, even in environments that
	 support binary or 8-bit transport, the use of a content-transfer-
	 encoding of "8bit" or "binary" is explicitly prohibited for entities
	 of type message/external-body.

7.3.3.1.	The "ftp" and "tftp" access-types

	 An access-type of FTP or TFTP indicates that the message body is
	 accessible as a file using the FTP [RFC-959] or TFTP [RFC-783]
	 protocols, respectively.	For these access-types, the following
	 additional parameters are mandatory:

			NAME -- The name of the file that contains the actual body data.

			SITE -- A machine from which the file may be obtained, using the
			given protocol. This must be a fully qualified domain name, not a
			nickname.

	 Before any data are retrieved, using FTP, the user will generally
	 need to be asked to provide a login id and a password for the machine
	 named by the site parameter.	For security reasons, such an id and
	 password are not specified as content-type parameters, but must be
	 obtained from the user.

	 In addition, the following parameters are optional:

			DIRECTORY -- A directory from which the data named by NAME should
			be retrieved.

			MODE -- A case-insensitive string indicating the mode to be used
			when retrieving the information.	The legal values for access-type
			"TFTP" are "NETASCII", "OCTET", and "MAIL", as specified by the
			TFTP protocol [RFC-783].	The legal values for access-type "FTP"
			are "ASCII", "EBCDIC", "IMAGE", and "LOCALn" where "n" is a
			decimal integer, typically 8.	These correspond to the



Borenstein & Freed																						 [Page 44]

RFC 1521													MIME										September 1993


			representation types "A" "E" "I" and "L n" as specified by the FTP
			protocol [RFC-959].	Note that "BINARY" and "TENEX" are not valid
			values for MODE, but that "OCTET" or "IMAGE" or "LOCAL8" should be
			used instead.	IF MODE is not specified, the default value is
			"NETASCII" for TFTP and "ASCII" otherwise.

7.3.3.2.	The "anon-ftp" access-type

	 The "anon-ftp" access-type is identical to the "ftp" access type,
	 except that the user need not be asked to provide a name and password
	 for the specified site.	Instead, the ftp protocol will be used with
	 login "anonymous" and a password that corresponds to the user's email
	 address.

7.3.3.3.	The "local-file" and "afs" access-types

	 An access-type of "local-file" indicates that the actual body is
	 accessible as a file on the local machine.	An access-type of "afs"
	 indicates that the file is accessible via the global AFS file system.
	 In both cases, only a single parameter is required:

			NAME -- The name of the file that contains the actual body data.

	 The following optional parameter may be used to describe the locality
	 of reference for the data, that is, the site or sites at which the
	 file is expected to be visible:

			SITE -- A domain specifier for a machine or set of machines that
			are known to have access to the data file.	Asterisks may be used
			for wildcard matching to a part of a domain name, such as
			"*.bellcore.com", to indicate a set of machines on which the data
			should be directly visible, while a single asterisk may be used to
			indicate a file that is expected to be universally available,
			e.g., via a global file system.

7.3.3.4.	The "mail-server" access-type

	 The "mail-server" access-type indicates that the actual body is
	 available from a mail server.	The mandatory parameter for this
	 access-type is:

			SERVER -- The email address of the mail server from which the
			actual body data can be obtained.

	 Because mail servers accept a variety of syntaxes, some of which is
	 multiline, the full command to be sent to a mail server is not
	 included as a parameter on the content-type line.	Instead, it is
	 provided as the "phantom body" when the content-type is



Borenstein & Freed																						 [Page 45]

RFC 1521													MIME										September 1993


	 message/external-body and the access- type is mail-server.

	 An optional parameter for this access-type is:

			SUBJECT -- The subject that is to be used in the mail that is sent
			to obtain the data. Note that keying mail servers on Subject lines
			is NOT recommended, but such mail servers are known to exist.

	 Note that MIME does not define a mail server syntax.	Rather, it
	 allows the inclusion of arbitrary mail server commands in the phantom
	 body.	Implementations must include the phantom body in the body of
	 the message it sends to the mail server address to retrieve the
	 relevant data.

	 It is worth noting that, unlike other access-types, mail-server
	 access is asynchronous and will happen at an unpredictable time in
	 the future.	For this reason, it is important that there be a
	 mechanism by which the returned data can be matched up with the
	 original message/external-body entity.	MIME mailservers must use the
	 same Content-ID field on the returned message that was used in the
	 original message/external-body entity, to facilitate such matching.

7.3.3.5.	Examples and Further Explanations

	 With the emerging possibility of very wide-area file systems, it
	 becomes very hard to know in advance the set of machines where a file
	 will and will not be accessible directly from the file system.
	 Therefore it may make sense to provide both a file name, to be tried
	 directly, and the name of one or more sites from which the file is
	 known to be accessible.	An implementation can try to retrieve remote
	 files using FTP or any other protocol, using anonymous file retrieval
	 or prompting the user for the necessary name and password.	If an
	 external body is accessible via multiple mechanisms, the sender may
	 include multiple parts of type message/external-body within an entity
	 of type multipart/alternative.

	 However, the external-body mechanism is not intended to be limited to
	 file retrieval, as shown by the mail-server access-type.	Beyond
	 this, one can imagine, for example, using a video server for external
	 references to video clips.

	 If an entity is of type "message/external-body", then the body of the
	 entity will contain the header fields of the encapsulated message.
	 The body itself is to be found in the external location.	This means
	 that if the body of the "message/external-body" message contains two
	 consecutive CRLFs, everything after those pairs is NOT part of the
	 message itself.	For most message/external-body messages, this
	 trailing area must simply be ignored.	However, it is a convenient



Borenstein & Freed																						 [Page 46]

RFC 1521													MIME										September 1993


	 place for additional data that cannot be included in the content-type
	 header field.	In particular, if the "access-type" value is "mail-
	 server", then the trailing area must contain commands to be sent to
	 the mail server at the address given by the value of the SERVER
	 parameter.

	 The embedded message header fields which appear in the body of the
	 message/external-body data must be used to declare the Content-type
	 of the external body if it is anything other than plain ASCII text,
	 since the external body does not have a header section to declare its
	 type.	Similarly, any Content-transfer-encoding other than "7bit"
	 must also be declared here.	Thus a complete message/external-body
	 message, referring to a document in PostScript format, might look
	 like this:

			From: Whomever
			To: Someone
			Subject: whatever
			MIME-Version: 1.0
			Message-ID: <id1@host.com>
			Content-Type: multipart/alternative; boundary=42
			Content-ID: <id001@guppylake.bellcore.com>

			--42
			Content-Type: message/external-body;
					 name="BodyFormats.ps";
					 site="thumper.bellcore.com";
					 access-type=ANON-FTP;
					 directory="pub";
					 mode="image";
					 expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

			Content-type: application/postscript
			Content-ID: <id42@guppylake.bellcore.com>

			--42
			Content-Type: message/external-body;
					 name="/u/nsb/writing/rfcs/RFC-MIME.ps";
					 site="thumper.bellcore.com";
					 access-type=AFS
					 expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

			Content-type: application/postscript
			Content-ID: <id42@guppylake.bellcore.com>

			--42
			Content-Type: message/external-body;
					 access-type=mail-server



Borenstein & Freed																						 [Page 47]

RFC 1521													MIME										September 1993


					 server="listserv@bogus.bitnet";
					 expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

			Content-type: application/postscript
			Content-ID: <id42@guppylake.bellcore.com>

			get RFC-MIME.DOC

			--42--

	 Note that in the above examples, the default Content-transfer-
	 encoding of "7bit" is assumed for the external postscript data.

	 Like the message/partial type, the message/external-body type is
	 intended to be transparent, that is, to convey the data type in the
	 external body rather than to convey a message with a body of that
	 type.	Thus the headers on the outer and inner parts must be merged
	 using the same rules as for message/partial.	In particular, this
	 means that the Content-type header is overridden, but the From and
	 Subject headers are preserved.

	 Note that since the external bodies are not transported as mail, they
	 need not conform to the 7-bit and line length requirements, but might
	 in fact be binary files.	Thus a Content-Transfer-Encoding is not
	 generally necessary, though it is permitted.

	 Note that the body of a message of type "message/external-body" is
	 governed by the basic syntax for an RFC 822 message.	In particular,
	 anything before the first consecutive pair of CRLFs is header
	 information, while anything after it is body information, which is
	 ignored for most access-types.

	 The formal grammar for content-type header fields for data of type
	 message is given by:

	 message-type := "message" "/" message-subtype

	 message-subtype := "rfc822"
									 / "partial" 2#3partial-param
									 / "external-body" 1*external-param
									 / extension-token

	 partial-param :=		 (";" "id" "=" value)
							/	(";" "number" "=" 1*DIGIT)
							/	(";" "total" "=" 1*DIGIT)
				 ; id & number required; total	required	for	last part

	 external-param :=	 (";" "access-type" "=" atype)



Borenstein & Freed																						 [Page 48]

RFC 1521													MIME										September 1993


							/ (";" "expiration" "=" date-time)
									 ; Note that date-time is quoted
							/ (";" "size" "=" 1*DIGIT)
							/ (";"	"permission"	"="	("read"	/	"read-write"))
									 ; Permission is case-insensitive
							/ (";" "name" "="	value)
							/ (";" "site" "=" value)
							/ (";" "dir" "=" value)
							/ (";" "mode" "=" value)
							/ (";" "server" "=" value)
							/ (";" "subject" "=" value)
					; access-type required;others required based on access-type

	 atype := "ftp" / "anon-ftp" / "tftp" / "local-file"
									/ "afs" / "mail-server" / extension-token
									; Case-insensitive

7.4.	The Application Content-Type

	 The "application" Content-Type is to be used for data which do not
	 fit in any of the other categories, and particularly for data to be
	 processed by mail-based uses of application programs.	This is
	 information which must be processed by an application before it is
	 viewable or usable to a user.	Expected uses for Content-Type
	 application include mail-based file transfer, spreadsheets, data for
	 mail-based scheduling systems, and languages for "active"
	 (computational) email.	(The latter, in particular, can pose security
	 problems which must be understood by implementors, and are considered
	 in detail in the discussion of the application/PostScript content-
	 type.)

	 For example, a meeting scheduler might define a standard
	 representation for information about proposed meeting dates.	An
	 intelligent user agent would use this information to conduct a dialog
	 with the user, and might then send further mail based on that dialog.
	 More generally, there have been several "active" messaging languages
	 developed in which programs in a suitably specialized language are
	 sent through the mail and automatically run in the recipient's
	 environment.

	 Such applications may be defined as subtypes of the "application"
	 Content-Type.	This document defines two subtypes: octet-stream, and
	 PostScript.

	 In general, the subtype of application will often be the name of the
	 application for which the data are intended.	This does not mean,
	 however, that any application program name may be used freely as a
	 subtype of application.	Such usages (other than subtypes beginning



Borenstein & Freed																						 [Page 49]

RFC 1521													MIME										September 1993


	 with "x-") must be registered with IANA, as described in Appendix E.

7.4.1.		 The Application/Octet-Stream (primary) subtype

	 The primary subtype of application, "octet-stream", may be used to
	 indicate that a body contains binary data.	The set of possible
	 parameters includes, but is not limited to:

			TYPE -- the general type or category of binary data.	This is
			intended as information for the human recipient rather than for
			any automatic processing.

			PADDING -- the number of bits of padding that were appended to the
			bit-stream comprising the actual contents to produce the enclosed
			byte-oriented data.	This is useful for enclosing a bit-stream in
			a body when the total number of bits is not a multiple of the byte
			size.

	 An additional parameter, "conversions", was defined in [RFC-1341] but
	 has been removed.

	 RFC 1341 also defined the use of a "NAME" parameter which gave a
	 suggested file name to be used if the data were to be written to a
	 file.	This has been deprecated in anticipation of a separate
	 Content-Disposition header field, to be defined in a subsequent RFC.

	 The recommended action for an implementation that receives
	 application/octet-stream mail is to simply offer to put the data in a
	 file, with any Content-Transfer-Encoding undone, or perhaps to use it
	 as input to a user-specified process.

	 To reduce the danger of transmitting rogue programs through the mail,
	 it is strongly recommended that implementations NOT implement a
	 path-search mechanism whereby an arbitrary program named in the
	 Content-Type parameter (e.g., an "interpreter=" parameter) is found
	 and executed using the mail body as input.

7.4.2.		 The Application/PostScript subtype

	 A Content-Type of "application/postscript" indicates a PostScript
	 program.	Currently two variants of the PostScript language are
	 allowed; the original level 1 variant is described in [POSTSCRIPT]
	 and the more recent level 2 variant is described in [POSTSCRIPT2].

	 PostScript is a registered trademark of Adobe Systems, Inc.	Use of
	 the MIME content-type "application/postscript" implies recognition of
	 that trademark and all the rights it entails.




Borenstein & Freed																						 [Page 50]

RFC 1521													MIME										September 1993


	 The PostScript language definition provides facilities for internal
	 labeling of the specific language features a given program uses. This
	 labeling, called the PostScript document structuring conventions, is
	 very general and provides substantially more information than just
	 the language level.

	 The use of document structuring conventions, while not required, is
	 strongly recommended as an aid to interoperability.	Documents which
	 lack proper structuring conventions cannot be tested to see whether
	 or not they will work in a given environment.	As such, some systems
	 may assume the worst and refuse to process unstructured documents.

	 The execution of general-purpose PostScript interpreters entails
	 serious security risks, and implementors are discouraged from simply
	 sending PostScript email bodies to "off-the-shelf" interpreters.
	 While it is usually safe to send PostScript to a printer, where the
	 potential for harm is greatly constrained, implementors should
	 consider all of the following before they add interactive display of
	 PostScript bodies to their mail readers.

	 The remainder of this section outlines some, though probably not all,
	 of the possible problems with sending PostScript through the mail.

	 Dangerous operations in the PostScript language include, but may not
	 be limited to, the PostScript operators deletefile, renamefile,
	 filenameforall, and file.	File is only dangerous when applied to
	 something other than standard input or output. Implementations may
	 also define additional nonstandard file operators; these may also
	 pose a threat to security.	Filenameforall, the wildcard file search
	 operator, may appear at first glance to be harmless. Note, however,
	 that this operator has the potential to reveal information about what
	 files the recipient has access to, and this information may itself be
	 sensitive.	Message senders should avoid the use of potentially
	 dangerous file operators, since these operators are quite likely to
	 be unavailable in secure PostScript implementations.	Message-
	 receiving and -displaying software should either completely disable
	 all potentially dangerous file operators or take special care not to
	 delegate any special authority to their operation. These operators
	 should be viewed as being done by an outside agency when interpreting
	 PostScript documents.	Such disabling and/or checking should be done
	 completely outside of the reach of the PostScript language itself;
	 care should be taken to insure that no method exists for re-enabling
	 full-function versions of these operators.

	 The PostScript language provides facilities for exiting the normal
	 interpreter, or server, loop. Changes made in this "outer"
	 environment are customarily retained across documents, and may in
	 some cases be retained semipermanently in nonvolatile memory. The



Borenstein & Freed																						 [Page 51]

RFC 1521													MIME										September 1993


	 operators associated with exiting the interpreter loop have the
	 potential to interfere with subsequent document processing. As such,
	 their unrestrained use constitutes a threat of service denial.
	 PostScript operators that exit the interpreter loop include, but may
	 not be limited to, the exitserver and startjob operators.	Message-
	 sending software should not generate PostScript that depends on
	 exiting the interpreter loop to operate. The ability to exit will
	 probably be unavailable in secure PostScript implementations.
	 Message-receiving and -displaying software should, if possible,
	 disable the ability to make retained changes to the PostScript
	 environment, and eliminate the startjob and exitserver commands.	If
	 these commands cannot be eliminated, the password associated with
	 them should at least be set to a hard-to-guess value.

	 PostScript provides operators for setting system-wide and device-
	 specific parameters. These parameter settings may be retained across
	 jobs and may potentially pose a threat to the correct operation of
	 the interpreter.	The PostScript operators that set system and device
	 parameters include, but may not be limited to, the setsystemparams
	 and setdevparams operators.	Message-sending software should not
	 generate PostScript that depends on the setting of system or device
	 parameters to operate correctly. The ability to set these parameters
	 will probably be unavailable in secure PostScript implementations.
	 Message-receiving and -displaying software should, if possible,
	 disable the ability to change system and device parameters.	If these
	 operators cannot be disabled, the password associated with them
	 should at least be set to a hard-to-guess value.

	 Some PostScript implementations provide nonstandard facilities for
	 the direct loading and execution of machine code.	Such facilities
	 are quite obviously open to substantial abuse.	Message-sending
	 software should not make use of such features. Besides being totally
	 hardware- specific, they are also likely to be unavailable in secure
	 implementations of PostScript.	Message-receiving and -displaying
	 software should not allow such operators to be used if they exist.

	 PostScript is an extensible language, and many, if not most,
	 implementations of it provide a number of their own extensions. This
	 document does not deal with such extensions explicitly since they
	 constitute an unknown factor.	Message-sending software should not
	 make use of nonstandard extensions; they are likely to be missing
	 from some implementations. Message-receiving and -displaying software
	 should make sure that any nonstandard PostScript operators are secure
	 and don't present any kind of threat.

	 It is possible to write PostScript that consumes huge amounts of
	 various system resources. It is also possible to write PostScript
	 programs that loop infinitely.	Both types of programs have the



Borenstein & Freed																						 [Page 52]

RFC 1521													MIME										September 1993


	 potential to cause damage if sent to unsuspecting recipients.
	 Message-sending software should avoid the construction and
	 dissemination of such programs, which is antisocial.	Message-
	 receiving and -displaying software should provide appropriate
	 mechanisms to abort processing of a document after a reasonable
	 amount of time has elapsed. In addition, PostScript interpreters
	 should be limited to the consumption of only a reasonable amount of
	 any given system resource.

	 Finally, bugs may exist in some PostScript interpreters which could
	 possibly be exploited to gain unauthorized access to a recipient's
	 system.	Apart from noting this possibility, there is no specific
	 action to take to prevent this, apart from the timely correction of
	 such bugs if any are found.

7.4.3.		 Other Application subtypes

	 It is expected that many other subtypes of application will be
	 defined in the future.	MIME implementations must generally treat any
	 unrecognized subtypes as being equivalent to application/octet-
	 stream.

	 The formal grammar for content-type header fields for application
	 data is given by:

	 application-type :=	"application" "/" application-subtype

	 application-subtype := ("octet-stream" *stream-param)
											 / "postscript" / extension-token

	 stream-param :=	(";" "type" "=" value)
											 / (";" "padding" "=" padding)

	 padding := "0" / "1" /	"2" /	"3" / "4" / "5" / "6" / "7"

7.5.	The Image Content-Type

	 A Content-Type of "image" indicates that the body contains an image.
	 The subtype names the specific image format.	These names are case
	 insensitive.	Two initial subtypes are "jpeg" for the JPEG format,
	 JFIF encoding, and "gif" for GIF format [GIF].

	 The list of image subtypes given here is neither exclusive nor
	 exhaustive, and is expected to grow as more types are registered with
	 IANA, as described in Appendix E.

	 The formal grammar for the content-type header field for data of type
	 image is given by:



Borenstein & Freed																						 [Page 53]

RFC 1521													MIME										September 1993


	 image-type := "image" "/" ("gif" / "jpeg" / extension-token)

7.6.	The Audio Content-Type

	 A Content-Type of "audio" indicates that the body contains audio
	 data.	Although there is not yet a consensus on an "ideal" audio
	 format for use with computers, there is a pressing need for a format
	 capable of providing interoperable behavior.

	 The initial subtype of "basic" is specified to meet this requirement
	 by providing an absolutely minimal lowest common denominator audio
	 format.	It is expected that richer formats for higher quality and/or
	 lower bandwidth audio will be defined by a later document.

	 The content of the "audio/basic" subtype is audio encoded using 8-bit
	 ISDN mu-law [PCM].	When this subtype is present, a sample rate of
	 8000 Hz and a single channel is assumed.

	 The formal grammar for the content-type header field for data of type
	 audio is given by:

	 audio-type := "audio" "/" ("basic" / extension-token)

7.7.	The Video Content-Type

	 A Content-Type of "video" indicates that the body contains a time-
	 varying-picture image, possibly with color and coordinated sound.
	 The term "video" is used extremely generically, rather than with
	 reference to any particular technology or format, and is not meant to
	 preclude subtypes such as animated drawings encoded compactly.	The
	 subtype "mpeg" refers to video coded according to the MPEG standard
	 [MPEG].

	 Note that although in general this document strongly discourages the
	 mixing of multiple media in a single body, it is recognized that many
	 so-called "video" formats include a representation for synchronized
	 audio, and this is explicitly permitted for subtypes of "video".

	 The formal grammar for the content-type header field for data of type
	 video is given by:

	 video-type := "video" "/" ("mpeg" / extension-token)

7.8.	Experimental Content-Type Values

	 A Content-Type value beginning with the characters "X-" is a private
	 value, to be used by consenting mail systems by mutual agreement.
	 Any format without a rigorous and public definition must be named



Borenstein & Freed																						 [Page 54]

RFC 1521													MIME										September 1993


	 with an "X-" prefix, and publicly specified values shall never begin
	 with "X-".	(Older versions of the widely-used Andrew system use the
	 "X-BE2" name, so new systems should probably choose a different
	 name.)

	 In general, the use of "X-" top-level types is strongly discouraged.
	 Implementors should invent subtypes of the existing types whenever
	 possible.	The invention of new types is intended to be restricted
	 primarily to the development of new media types for email, such as
	 digital odors or holography, and not for new data formats in general.
	 In many cases, a subtype of application will be more appropriate than
	 a new top-level type.







































Borenstein & Freed																						 [Page 55]

RFC 1521													MIME										September 1993


8. Summary

	 Using the MIME-Version, Content-Type, and Content-Transfer-Encoding
	 header fields, it is possible to include, in a standardized way,
	 arbitrary types of data objects with RFC 822 conformant mail
	 messages.	No restrictions imposed by either RFC 821 or RFC 822 are
	 violated, and care has been taken to avoid problems caused by
	 additional restrictions imposed by the characteristics of some
	 Internet mail transport mechanisms (see Appendix B). The "multipart"
	 and "message" Content-Types allow mixing and hierarchical structuring
	 of objects of different types in a single message.	Further Content-
	 Types provide a standardized mechanism for tagging messages or body
	 parts as audio, image, or several other kinds of data.	A
	 distinguished parameter syntax allows further specification of data
	 format details, particularly the specification of alternate character
	 sets.	Additional optional header fields provide mechanisms for
	 certain extensions deemed desirable by many implementors.	Finally, a
	 number of useful Content-Types are defined for general use by
	 consenting user agents, notably message/partial, and
	 message/external-body.

9. Security Considerations

	 Security issues are discussed in Section 7.4.2 and in Appendix F.
	 Implementors should pay special attention to the security
	 implications of any mail content-types that can cause the remote
	 execution of any actions in the recipient's environment.	In such
	 cases, the discussion of the application/postscript content-type in
	 Section 7.4.2 may serve as a model for considering other content-
	 types with remote execution capabilities.





















Borenstein & Freed																						 [Page 56]

RFC 1521													MIME										September 1993


10. Authors' Addresses

	 For more information, the authors of this document may be contacted
	 via Internet mail:

	 Nathaniel S. Borenstein
	 MRE 2D-296, Bellcore
	 445 South St.
	 Morristown, NJ 07962-1910

	 Phone: +1 201 829 4270
	 Fax:	+1 201 829 7019
	 Email: nsb@bellcore.com


	 Ned Freed
	 Innosoft International, Inc.
	 250 West First Street
	 Suite 240
	 Claremont, CA 91711

	 Phone:	+1 909 624 7907
	 Fax: +1 909 621 5319
	 Email: ned@innosoft.com

	 MIME is a result of the work of the Internet Engineering Task Force
	 Working Group on Email Extensions. The chairman of that group, Greg
	 Vaudreuil, may be reached at:

	 Gregory M. Vaudreuil
	 Tigon Corporation
	 17060 Dallas Parkway
	 Dallas Texas, 75248

	 Phone:		+1 214-733-2722
	 EMail: gvaudre@cnri.reston.va.us















Borenstein & Freed																						 [Page 57]

RFC 1521													MIME										September 1993


11. Acknowledgements

	 This document is the result of the collective effort of a large
	 number of people, at several IETF meetings, on the IETF-SMTP and
	 IETF-822 mailing lists, and elsewhere.	Although any enumeration
	 seems doomed to suffer from egregious omissions, the following are
	 among the many contributors to this effort:

						Harald Tveit Alvestrand			 Timo Lehtinen
						Randall Atkinson							John R. MacMillan
						Philippe Brandon							Rick McGowan
						Kevin Carosso								 Leo Mclaughlin
						Uhhyung Choi									Goli Montaser-Kohsari
						Cristian Constantinof				 Keith Moore
						Mark Crispin									Tom Moore
						Dave Crocker									Erik Naggum
						Terry Crowley								 Mark Needleman
						Walt Daniels									John Noerenberg
						Frank Dawson									Mats Ohrman
						Hitoshi Doi									 Julian Onions
						Kevin Donnelly								Michael Patton
						Keith Edwards								 David J. Pepper
						Chris Eich										Blake C. Ramsdell
						Johnny Eriksson							 Luc Rooijakkers
						Craig Everhart								Marshall T. Rose
						Patrik Faeltstroem						Jonathan Rosenberg
						Erik E. Fair									Jan Rynning
						Roger Fajman									Harri Salminen
						Alain Fontaine								Michael Sanderson
						James M. Galvin							 Masahiro Sekiguchi
						Philip Gladstone							Mark Sherman
						Thomas Gordon								 Keld Simonsen
						Phill Gross									 Bob Smart
						James Hamilton								Peter Speck
						Steve Hardcastle-Kille				Henry Spencer
						David Herron									Einar Stefferud
						Bruce Howard									Michael Stein
						Bill Janssen									Klaus Steinberger
						Olle Jaernefors							 Peter Svanberg
						Risto Kankkunen							 James Thompson
						Phil Karn										 Steve Uhler
						Alan Katz										 Stuart Vance
						Tim Kehres										Erik van der Poel
						Neil Katin										Guido van Rossum
						Kyuho Kim										 Peter Vanderbilt
						Anders Klemets								Greg Vaudreuil
						John Klensin									Ed Vielmetti
						Valdis Kletniek							 Ryan Waldron



Borenstein & Freed																						 [Page 58]

RFC 1521													MIME										September 1993


						Jim Knowles									 Wally Wedel
						Stev Knowles									Sven-Ove Westberg
						Bob Kummerfeld								Brian Wideen
						Pekka Kytolaakso							John Wobus
						Stellan Lagerstrom						Glenn Wright
						Vincent Lau									 Rayan Zachariassen
						Donald Lindsay								David Zimmerman
						Marc Andreessen							 Bob Braden
						Brian Capouch								 Peter Clitherow
						Dave Collier-Brown						John Coonrod
						Stephen Crocker							 Jim Davis
						Axel Deininger								Dana S Emery
						Martin Forssen								Stephen Gildea
						Terry Gray										Mark Horton
						Warner Losh									 Carlyn Lowery
						Laurence Lundblade						Charles Lynn
						Larry Masinter								Michael J. McInerny
						Jon Postel										Christer Romson
						Yutaka Sato									 Markku Savela
						Richard Alan Schafer					Larry W. Virden
						Rhys Weatherly								Jay Weber
						Dave Wecker

The authors apologize for any omissions from this list, which are
certainly unintentional.


























Borenstein & Freed																						 [Page 59]

RFC 1521													MIME										September 1993


Appendix A -- Minimal MIME-Conformance

	 The mechanisms described in this document are open-ended.	It is
	 definitely not expected that all implementations will support all of
	 the Content-Types described, nor that they will all share the same
	 extensions.	In order to promote interoperability, however, it is
	 useful to define the concept of "MIME-conformance" to define a
	 certain level of implementation that allows the useful interworking
	 of messages with content that differs from US ASCII text.	In this
	 section, we specify the requirements for such conformance.

	 A mail user agent that is MIME-conformant MUST:

			1.	Always generate a "MIME-Version: 1.0" header field.

			2.	Recognize the Content-Transfer-Encoding header field, and
			decode all received data encoded with either the quoted-printable
			or base64 implementations.	Encode any data sent that is not in
			seven-bit mail-ready representation using one of these
			transformations and include the appropriate Content-Transfer-
			Encoding header field, unless the underlying transport mechanism
			supports non-seven-bit data, as SMTP does not.

			3.	Recognize and interpret the Content-Type header field, and
			avoid showing users raw data with a Content-Type field other than
			text.	Be able to send at least text/plain messages, with the
			character set specified as a parameter if it is not US-ASCII.

			4.	Explicitly handle the following Content-Type values, to at
			least the following extents:

			Text:

						-- Recognize and display "text" mail
								 with the character set "US-ASCII."

						-- Recognize other character sets at
								 least to the extent of being able
								 to inform the user about what
								 character set the message uses.

						-- Recognize the "ISO-8859-*" character
								 sets to the extent of being able to
								 display those characters that are
								 common to ISO-8859-* and US-ASCII,
								 namely all characters represented
								 by octet values 0-127.




Borenstein & Freed																						 [Page 60]

RFC 1521													MIME										September 1993


						-- For unrecognized subtypes, show or
								 offer to show the user the "raw"
								 version of the data after
								 conversion of the content from
								 canonical form to local form.

			 Message:

						-- Recognize and display at least the
								 primary (822) encapsulation.

			 Multipart:

						-- Recognize the primary (mixed)
								 subtype.	Display all relevant
								 information on the message level
								 and the body part header level and
								 then display or offer to display
								 each of the body parts individually.

						-- Recognize the "alternative" subtype,
								 and avoid showing the user
								 redundant parts of
								 multipart/alternative mail.

						-- Treat any unrecognized subtypes as if
								 they were "mixed".

			 Application:

						-- Offer the ability to remove either of
								 the two types of Content-Transfer-
								 Encoding defined in this document
								 and put the resulting information
								 in a user file.

			5.	Upon encountering any unrecognized Content- Type, an
			implementation must treat it as if it had a Content-Type of
			"application/octet-stream" with no parameter sub-arguments.	How
			such data are handled is up to an implementation, but likely
			options for handling such unrecognized data include offering the
			user to write it into a file (decoded from its mail transport
			format) or offering the user to name a program to which the
			decoded data should be passed as input.	Unrecognized predefined
			types, which in a MIME-conformant mailer might still include
			audio, image, or video, should also be treated in this way.

	 A user agent that meets the above conditions is said to be MIME-



Borenstein & Freed																						 [Page 61]

RFC 1521													MIME										September 1993


	 conformant.	The meaning of this phrase is that it is assumed to be
	 "safe" to send virtually any kind of properly-marked data to users of
	 such mail systems, because such systems will at least be able to
	 treat the data as undifferentiated binary, and will not simply splash
	 it onto the screen of unsuspecting users.	There is another sense in
	 which it is always "safe" to send data in a format that is MIME-
	 conformant, which is that such data will not break or be broken by
	 any known systems that are conformant with RFC 821 and RFC 822.	User
	 agents that are MIME-conformant have the additional guarantee that
	 the user will not be shown data that were never intended to be viewed
	 as text.








































Borenstein & Freed																						 [Page 62]

RFC 1521													MIME										September 1993


Appendix B -- General Guidelines For Sending Email Data

	 Internet email is not a perfect, homogeneous system.	Mail may become
	 corrupted at several stages in its travel to a final destination.
	 Specifically, email sent throughout the Internet may travel across
	 many networking technologies.	Many networking and mail technologies
	 do not support the full functionality possible in the SMTP transport
	 environment. Mail traversing these systems is likely to be modified
	 in such a way that it can be transported.

	 There exist many widely-deployed non-conformant MTAs in the Internet.
	 These MTAs, speaking the SMTP protocol, alter messages on the fly to
	 take advantage of the internal data structure of the hosts they are
	 implemented on, or are just plain broken.

	 The following guidelines may be useful to anyone devising a data
	 format (Content-Type) that will survive the widest range of
	 networking technologies and known broken MTAs unscathed.	Note that
	 anything encoded in the base64 encoding will satisfy these rules, but
	 that some well-known mechanisms, notably the UNIX uuencode facility,
	 will not.	Note also that anything encoded in the Quoted-Printable
	 encoding will survive most gateways intact, but possibly not some
	 gateways to systems that use the EBCDIC character set.

			(1) Under some circumstances the encoding used for data may change
			as part of normal gateway or user agent operation. In particular,
			conversion from base64 to quoted-printable and vice versa may be
			necessary. This may result in the confusion of CRLF sequences with
			line breaks in text bodies. As such, the persistence of CRLF as
			something other than a line break must not be relied on.

			(2) Many systems may elect to represent and store text data using
			local newline conventions. Local newline conventions may not match
			the RFC822 CRLF convention -- systems are known that use plain CR,
			plain LF, CRLF, or counted records.	The result is that isolated
			CR and LF characters are not well tolerated in general; they may
			be lost or converted to delimiters on some systems, and hence must
			not be relied on.

			(3) TAB (HT) characters may be misinterpreted or may be
			automatically converted to variable numbers of spaces.	This is
			unavoidable in some environments, notably those not based on the
			ASCII character set. Such conversion is STRONGLY DISCOURAGED, but
			it may occur, and mail formats must not rely on the persistence of
			TAB (HT) characters.

			(4) Lines longer than 76 characters may be wrapped or truncated in
			some environments. Line wrapping and line truncation are STRONGLY



Borenstein & Freed																						 [Page 63]

RFC 1521													MIME										September 1993


			DISCOURAGED, but unavoidable in some cases. Applications which
			require long lines must somehow differentiate between soft and
			hard line breaks.	(A simple way to do this is to use the quoted-
			printable encoding.)

			(5) Trailing "white space" characters (SPACE, TAB (HT)) on a line
			may be discarded by some transport agents, while other transport
			agents may pad lines with these characters so that all lines in a
			mail file are of equal length.	The persistence of trailing white
			space, therefore, must not be relied on.

			(6) Many mail domains use variations on the ASCII character set,
			or use character sets such as EBCDIC which contain most but not
			all of the US-ASCII characters.	The correct translation of
			characters not in the "invariant" set cannot be depended on across
			character converting gateways.	For example, this situation is a
			problem when sending uuencoded information across BITNET, an
			EBCDIC system.	Similar problems can occur without crossing a
			gateway, since many Internet hosts use character sets other than
			ASCII internally.	The definition of Printable Strings in X.400
			adds further restrictions in certain special cases.	In
			particular, the only characters that are known to be consistent
			across all gateways are the 73 characters that correspond to the
			upper and lower case letters A-Z and a-z, the 10 digits 0-9, and
			the following eleven special characters:

												"'"	(ASCII code 39)
												"("	(ASCII code 40)
												")"	(ASCII code 41)
												"+"	(ASCII code 43)
												","	(ASCII code 44)
												"-"	(ASCII code 45)
												"."	(ASCII code 46)
												"/"	(ASCII code 47)
												":"	(ASCII code 58)
												"="	(ASCII code 61)
												"?"	(ASCII code 63)

			A maximally portable mail representation, such as the base64
			encoding, will confine itself to relatively short lines of text in
			which the only meaningful characters are taken from this set of 73
			characters.

			(7) Some mail transport agents will corrupt data that includes
			certain literal strings.	In particular, a period (".") alone on a
			line is known to be corrupted by some (incorrect) SMTP
			implementations, and a line that starts with the five characters
			"From " (the fifth character is a SPACE) are commonly corrupted as



Borenstein & Freed																						 [Page 64]

RFC 1521													MIME										September 1993


			well.	A careful composition agent can prevent these corruptions
			by encoding the data (e.g., in the quoted-printable encoding,
			"=46rom " in place of "From " at the start of a line, and "=2E" in
			place of "." alone on a line.

	 Please note that the above list is NOT a list of recommended
	 practices for MTAs.	RFC 821 MTAs are prohibited from altering the
	 character of white space or wrapping long lines.	These BAD and
	 illegal practices are known to occur on established networks, and
	 implementations should be robust in dealing with the bad effects they
	 can cause.








































Borenstein & Freed																						 [Page 65]

RFC 1521													MIME										September 1993


Appendix C -- A Complex Multipart Example

	 What follows is the outline of a complex multipart message.	This
	 message has five parts to be displayed serially: two introductory
	 plain text parts, an embedded multipart message, a richtext part, and
	 a closing encapsulated text message in a non-ASCII character set.
	 The embedded multipart message has two parts to be displayed in
	 parallel, a picture and an audio fragment.

			MIME-Version: 1.0
			From: Nathaniel Borenstein <nsb@bellcore.com>
			To: Ned Freed <ned@innosoft.com>
			Subject: A multipart example
			Content-Type: multipart/mixed;
					 boundary=unique-boundary-1

			This is the preamble area of a multipart message.
			Mail readers that understand multipart format
			should ignore this preamble.
			If you are reading this text, you might want to
			consider changing to a mail reader that understands
			how to properly display multipart messages.
			--unique-boundary-1

				 ...Some text appears here...
			[Note that the preceding blank line means
			no header fields were given and this is text,
			with charset US ASCII.	It could have been
			done with explicit typing as in the next part.]

			--unique-boundary-1
			Content-type: text/plain; charset=US-ASCII

			This could have been part of the previous part,
			but illustrates explicit versus implicit
			typing of body parts.

			--unique-boundary-1
			Content-Type: multipart/parallel;
					 boundary=unique-boundary-2


			--unique-boundary-2
			Content-Type: audio/basic
			Content-Transfer-Encoding: base64

				 ... base64-encoded 8000 Hz single-channel
						 mu-law-format audio data goes here....



Borenstein & Freed																						 [Page 66]

RFC 1521													MIME										September 1993


			--unique-boundary-2
			Content-Type: image/gif
			Content-Transfer-Encoding: base64

				 ... base64-encoded image data goes here....

			--unique-boundary-2--

			--unique-boundary-1
			Content-type: text/richtext

			This is <bold><italic>richtext.</italic></bold>
			<smaller>as defined in RFC 1341</smaller>
			<nl><nl>Isn't it
			<bigger><bigger>cool?</bigger></bigger>

			--unique-boundary-1
			Content-Type: message/rfc822

			From: (mailbox in US-ASCII)
			To: (address in US-ASCII)
			Subject: (subject in US-ASCII)
			Content-Type: Text/plain; charset=ISO-8859-1
			Content-Transfer-Encoding: Quoted-printable

				 ... Additional text in ISO-8859-1 goes here ...

			--unique-boundary-1--























Borenstein & Freed																						 [Page 67]

RFC 1521													MIME										September 1993


Appendix D -- Collected Grammar

	 This appendix contains the complete BNF grammar for all the syntax
	 specified by this document.

	 By itself, however, this grammar is incomplete.	It refers to several
	 entities that are defined by RFC 822.	Rather than reproduce those
	 definitions here, and risk unintentional differences between the two,
	 this document simply refers the reader to RFC 822 for the remaining
	 definitions.	Wherever a term is undefined, it refers to the RFC 822
	 definition.

	 application-subtype := ("octet-stream" *stream-param)
											 / "postscript" / extension-token

	 application-type :=	"application" "/" application-subtype

	 attribute := token		; case-insensitive

	 atype := "ftp" / "anon-ftp" / "tftp" / "local-file"
									/ "afs" / "mail-server" / extension-token
									; Case-insensitive

	 audio-type := "audio" "/" ("basic" / extension-token)

	 body-part := <"message" as defined in RFC 822,
						with all header fields optional, and with the
						specified delimiter not occurring anywhere in
						the message body, either on a line by itself
						or as a substring anywhere.>

			NOTE: In certain transport enclaves, RFC 822 restrictions such as
			the one that limits bodies to printable ASCII characters may not
			be in force.	(That is, the transport domains may resemble
			standard Internet mail transport as specified in RFC821 and
			assumed by RFC822, but without certain restrictions.)	The
			relaxation of these restrictions should be construed as locally
			extending the definition of bodies, for example to include octets
			outside of the ASCII range, as long as these extensions are
			supported by the transport and adequately documented in the
			Content-Transfer-Encoding header field. However, in no event are
			headers (either message headers or body-part headers) allowed to
			contain anything other than ASCII characters.








Borenstein & Freed																						 [Page 68]

RFC 1521													MIME										September 1993


	 boundary := 0*69<bchars> bcharsnospace

	 bchars := bcharsnospace / " "

	 bcharsnospace :=		DIGIT / ALPHA / "'" / "(" / ")" / "+"	/ "_"
									/ "," / "-" / "." / "/" / ":" / "=" / "?"

	 charset := "us-ascii" / "iso-8859-1" / "iso-8859-2"/ "iso-8859-3"
				/ "iso-8859-4" / "iso-8859-5" /	"iso-8859-6" / "iso-8859-7"
				/ "iso-8859-8" / "iso-8859-9" / extension-token
				; case insensitive

	 close-delimiter := "--" boundary "--" CRLF;Again,no space by "--",

	 content	:= "Content-Type"	":" type "/" subtype	*(";" parameter)
						 ; case-insensitive matching of type and subtype

	 delimiter := "--" boundary CRLF	;taken from Content-Type field.
																; There must be no space
																; between "--" and boundary.

	 description := "Content-Description" ":" *text

	 discard-text := *(*text CRLF)

	 encapsulation := delimiter body-part CRLF

	 encoding := "Content-Transfer-Encoding" ":" mechanism

	 epilogue := discard-text				;	to	be	ignored upon receipt.

	 extension-token :=	x-token / iana-token

	 external-param :=	 (";" "access-type" "=" atype)
									/ (";" "expiration" "=" date-time)

											 ; Note that date-time is quoted
									/ (";" "size" "=" 1*DIGIT)
									/ (";"	"permission"	"="	("read" / "read-write"))
											 ; Permission is case-insensitive
									/ (";" "name" "="	value)
									/ (";" "site" "=" value)
									/ (";" "dir" "=" value)
									/ (";" "mode" "=" value)
									/ (";" "server" "=" value)
									/ (";" "subject" "=" value)
					 ;access-type required; others required based on access-type




Borenstein & Freed																						 [Page 69]

RFC 1521													MIME										September 1993


	 iana-token := <a publicly-defined extension token,
						 registered with IANA, as specified in
						 appendix E>

	 id :=	"Content-ID" ":" msg-id

	 image-type := "image" "/" ("gif" / "jpeg" / extension-token)

	 mechanism :=		 "7bit"		;	case-insensitive
									/ "quoted-printable"
									/ "base64"
									/ "8bit"
									/ "binary"
									/ x-token

	 message-subtype := "rfc822"
									/ "partial" 2#3partial-param
									/ "external-body" 1*external-param
									/ extension-token

	 message-type := "message" "/" message-subtype

	 multipart-body :=preamble 1*encapsulation close-delimiter epilogue

	 multipart-subtype := "mixed" / "parallel" / "digest"
									/ "alternative" / extension-token

	 multipart-type := "multipart" "/" multipart-subtype
									";" "boundary" "=" boundary

	 octet := "=" 2(DIGIT / "A" / "B" / "C" / "D" / "E" / "F")
				; octet must be used for characters > 127, =, SPACE, or
	 TAB,
				; and is recommended for any characters not listed in
				; Appendix B as "mail-safe".

	 padding := "0" / "1" /	"2" /	"3" / "4" / "5" / "6" / "7"

	 parameter := attribute "=" value

	 partial-param :=		 (";" "id" "=" value)
									/	(";" "number" "=" 1*DIGIT)
									/	(";" "total" "=" 1*DIGIT)
						 ; id & number required;total required for last part

	 preamble := discard-text			 ;	to	be	ignored upon receipt.

	 ptext := octet / <any ASCII character except "=", SPACE,	or TAB>



Borenstein & Freed																						 [Page 70]

RFC 1521													MIME										September 1993


				; characters not listed as "mail-safe" in Appendix B
				; are also not recommended.

	 quoted-printable := ([*(ptext / SPACE /	TAB)	ptext]	["="] CRLF)
				; Maximum line length of 76 characters excluding CRLF

	 stream-param :=	(";" "type" "=" value)
								/ (";" "padding" "=" padding)

	 subtype := token	; case-insensitive

	 text-subtype := "plain" / extension-token

	 text-type := "text" "/" text-subtype [";" "charset" "=" charset]

	 token	:=	1*<any	(ASCII) CHAR except SPACE, CTLs, or tspecials>

	 tspecials :=	"(" / ")" / "<" / ">" / "@"
							/	"," / ";" / ":" / "\" / <">
							/	"/" / "[" / "]" / "?" / "="
						 ; Must be in quoted-string,
						 ; to use within parameter values


	 type :=		 "application"		 /	"audio"	 ; case-insensitive
						 / "image"					 / "message"
						 / "multipart"	/ "text"
						 / "video"					 / extension-token
						 ; All values case-insensitive

	 value := token / quoted-string

	 version := "MIME-Version" ":" 1*DIGIT "." 1*DIGIT

	 video-type := "video" "/" ("mpeg" / extension-token)

	 x-token := <The two characters "X-" or "x-" followed, with no
							intervening white space, by any token>













Borenstein & Freed																						 [Page 71]

RFC 1521													MIME										September 1993


Appendix E -- IANA Registration Procedures

	 MIME has been carefully designed to have extensible mechanisms, and
	 it is expected that the set of content-type/subtype pairs and their
	 associated parameters will grow significantly with time.	Several
	 other MIME fields, notably character set names, access-type
	 parameters for the message/external-body type, and possibly even
	 Content-Transfer-Encoding values, are likely to have new values
	 defined over time.	In order to ensure that the set of such values is
	 developed in an orderly, well-specified, and public manner, MIME
	 defines a registration process which uses the Internet Assigned
	 Numbers Authority (IANA) as a central registry for such values.

	 In general, parameters in the content-type header field are used to
	 convey supplemental information for various content types, and their
	 use is defined when the content-type and subtype are defined.	New
	 parameters should not be defined as a way to introduce new
	 functionality.

	 In order to simplify and standardize the registration process, this
	 appendix gives templates for the registration of new values with
	 IANA.	Each of these is given in the form of an email message
	 template, to be filled in by the registering party.

	 E.1	Registration of New Content-type/subtype Values

	 Note that MIME is generally expected to be extended by subtypes.	If
	 a new fundamental top-level type is needed, its specification must be
	 published as an RFC or submitted in a form suitable to become an RFC,
	 and be subject to the Internet standards process.

			To:	IANA@isi.edu
			Subject:	Registration of new MIME
					 content-type/subtype

			MIME type name:

			(If the above is not an existing top-level MIME type,
			please explain why an existing type cannot be used.)

			MIME subtype name:

			Required parameters:

			Optional parameters:

			Encoding considerations:




Borenstein & Freed																						 [Page 72]

RFC 1521													MIME										September 1993


			Security considerations:

			Published specification:

			(The published specification must be an Internet RFC or
			RFC-to-be if a new top-level type is being defined, and
			must be a publicly available specification in any
			case.)

			Person & email address to contact for further information:

	 E.2	Registration of New Access-type Values
					 for Message/external-body

			To:	IANA@isi.edu
			Subject:	Registration of new MIME Access-type for
					 Message/external-body content-type

			MIME access-type name:

			Required parameters:

			Optional parameters:

			Published specification:

			(The published specification must be an Internet RFC or
			RFC-to-be.)

			Person & email address to contact for further information:





















Borenstein & Freed																						 [Page 73]

RFC 1521													MIME										September 1993


Appendix F -- Summary of the Seven Content-types

	 Content-type: text

	 Subtypes defined by this document:	plain

	 Important Parameters: charset

	 Encoding notes: quoted-printable generally preferred if an encoding
			is needed and the character set is mostly an ASCII superset.

	 Security considerations: Rich text formats such as TeX and Troff
			often contain mechanisms for executing arbitrary commands or file
			system operations, and should not be used automatically unless
			these security problems have been addressed.	Even plain text may
			contain control characters that can be used to exploit the
			capabilities of "intelligent" terminals and cause security
			violations.	User interfaces designed to run on such terminals
			should be aware of and try to prevent such problems.

	 ________________________________________________________
	 Content-type: multipart

	 Subtypes defined by	this	document: mixed, alternative,
				digest, parallel.

	 Important Parameters: boundary

	 Encoding notes: No content-transfer-encoding is permitted.

	 ________________________________________________________
	 Content-type: message

	 Subtypes defined by this document: rfc822, partial, external-body

	 Important Parameters: id, number, total, access-type, expiration,
			size, permission, name, site, directory, mode, server, subject

	 Encoding notes: No content-transfer-encoding is permitted.
			Specifically, only "7bit" is permitted for "message/partial" or
			"message/external-body", and only "7bit", "8bit", or "binary" are
			permitted for other subtypes of "message".
	 ______________________________________________________________
	 Content-type: application

	 Subtypes defined by this document:	octet-stream, postscript

	 Important Parameters:	type, padding



Borenstein & Freed																						 [Page 74]

RFC 1521													MIME										September 1993


	 Deprecated Parameters: name and conversions were
													defined in RFC 1341.

	 Encoding notes: base64 preferred for unreadable subtypes.

	 Security considerations:	This	type	is	intended	for	the
	 transmission	of data to be interpreted by locally-installed
	 programs.	If used,	for	example,	to	transmit	executable
	 binary	programs	or programs in general-purpose interpreted
	 languages, such as LISP programs or	shell	scripts,	severe
	 security	problems	could	result.	 Authors of mail-reading
	 agents are cautioned against giving their systems the	power
	 to	execute	mail-based	application	data without carefully
	 considering	the	security	implications.		While	 it	 is
	 certainly	possible	to	define safe application formats and
	 even safe interpreters for unsafe formats, each	interpreter
	 should	 be	 evaluated	separately	for	possible	security
	 problems.
	 ________________________________________________________________
	 Content-type: image

	 Subtypes defined by this document:	jpeg, gif

	 Important Parameters: none

	 Encoding notes: base64 generally preferred
	 ________________________________________________________________
	 Content-type: audio

	 Subtypes defined by this document:	basic

	 Important Parameters: none

	 Encoding notes: base64 generally preferred
	 ________________________________________________________________
	 Content-type: video

	 Subtypes defined by this document:	mpeg

	 Important Parameters: none

	 Encoding notes: base64 generally preferred









Borenstein & Freed																						 [Page 75]

RFC 1521													MIME										September 1993


Appendix G -- Canonical Encoding Model

	 There was some confusion, in earlier drafts of this memo, regarding
	 the model for when email data was to be converted to canonical form
	 and encoded, and in particular how this process would affect the
	 treatment of CRLFs, given that the representation of newlines varies
	 greatly from system to system.	For this reason, a canonical model
	 for encoding is presented below.

	 The process of composing a MIME entity can be modeled as being done
	 in a number of steps.	Note that these steps are roughly similar to
	 those steps used in RFC 1421 and are performed for each 'innermost
	 level' body:

	 Step 1.	Creation of local form.

	 The body to be transmitted is created in the system's native format.
	 The native character set is used, and where appropriate local end of
	 line conventions are used as well.	The body may be a UNIX-style text
	 file, or a Sun raster image, or a VMS indexed file, or audio data in
	 a system-dependent format stored only in memory, or anything else
	 that corresponds to the local model for the representation of some
	 form of information.	Fundamentally, the data is created in the
	 "native" form specified by the type/subtype information.

	 Step 2.	Conversion to canonical form.

	 The entire body, including "out-of-band" information such as record
	 lengths and possibly file attribute information, is converted to a
	 universal canonical form.	The specific content type of the body as
	 well as its associated attributes dictate the nature of the canonical
	 form that is used.	Conversion to the proper canonical form may
	 involve character set conversion, transformation of audio data,
	 compression, or various other operations specific to the various
	 content types.	If character set conversion is involved, however,
	 care must be taken to understand the semantics of the content-type,
	 which may have strong implications for any character set conversion,
	 e.g.	with regard to syntactically meaningful characters in a text
	 subtype other than "plain".

	 For example, in the case of text/plain data, the text must be
	 converted to a supported character set and lines must be delimited
	 with CRLF delimiters in accordance with RFC822.	Note that the
	 restriction on line lengths implied by RFC822 is eliminated if the
	 next step employs either quoted-printable or base64 encoding.






Borenstein & Freed																						 [Page 76]

RFC 1521													MIME										September 1993


	 Step 3.	Apply transfer encoding.

	 A Content-Transfer-Encoding appropriate for this body is applied.
	 Note that there is no fixed relationship between the content type and
	 the transfer encoding.	In particular, it may be appropriate to base
	 the choice of base64 or quoted-printable on character frequency
	 counts which are specific to a given instance of a body.

	 Step 4.	Insertion into entity.

	 The encoded object is inserted into a MIME entity with appropriate
	 headers.	The entity is then inserted into the body of a higher-level
	 entity (message or multipart) if needed.

	 It is vital to note that these steps are only a model; they are
	 specifically NOT a blueprint for how an actual system would be built.
	 In particular, the model fails to account for two common designs:

			1.	In many cases the conversion to a canonical form prior to
			encoding will be subsumed into the encoder itself, which
			understands local formats directly.	For example, the local
			newline convention for text bodies might be carried through to the
			encoder itself along with knowledge of what that format is.

			2.	The output of the encoders may have to pass through one or
			more additional steps prior to being transmitted as a message.	As
			such, the output of the encoder may not be conformant with the
			formats specified by RFC822.	In particular, once again it may be
			appropriate for the converter's output to be expressed using local
			newline conventions rather than using the standard RFC822 CRLF
			delimiters.

	 Other implementation variations are conceivable as well.	The vital
	 aspect of this discussion is that, in spite of any optimizations,
	 collapsings of required steps, or insertion of additional processing,
	 the resulting messages must be consistent with those produced by the
	 model described here.	For example, a message with the following
	 header fields:

				Content-type: text/foo; charset=bar
				Content-Transfer-Encoding: base64

	 must be first represented in the text/foo form, then (if necessary)
	 represented in the "bar" character set, and finally transformed via
	 the base64 algorithm into a mail-safe form.






Borenstein & Freed																						 [Page 77]

RFC 1521													MIME										September 1993


Appendix H -- Changes from RFC 1341

	 This document is a relatively minor revision	of	RFC	1341.	For
	 the	convenience	of	those familiar with RFC 1341, the technical
	 changes from that document are summarized in	this appendix.

	 1.	The definition of "tspecials" has been changed to no longer
	 include ".".

	 2.	The Content-ID field is now mandatory for message/external-body
	 parts.

	 3.	The text/richtext type (including the old Section 7.1.3 and
	 Appendix D) has been moved to a separate document.

	 4.	The rules on header merging for message/partial data have been
	 changed to treat the Encrypted and MIME-Version headers as special
	 cases.

	 5.	The definition of the external-body access-type parameter has
	 been changed so that it can only indicate a single access method
	 (which was all that made sense).

	 6.	There is a new "Subject" parameter for message/external-body,
	 access-type mail-server, to permit MIME-based use of mail servers
	 that rely on Subject field information.

	 7.	The "conversions" parameter for application/octet-stream has been
	 removed.

	 8.	Section 7.4.1 now deprecates the use of the "name" parameter for
	 application/octet-stream, as this will be superseded in the future by
	 a Content-Disposition header.

	 9.	The formal grammar for multipart bodies has been changed so that
	 a CRLF is no longer required before the first boundary line.

	 10.	MIME entities of type "message/partial" and "message/external-
	 body" are now required to use only the "7bit" transfer-encoding.
	 (Specifically, "binary" and "8bit" are not permitted.)

	 11.	The "application/oda" content-type has been removed.

	 12.	A note has been added to the end of section 7.2.3, explaining
	 the semantics of Content-ID in a multipart/alternative MIME entity.

	 13.	The formal syntax for the "MIME-Version" field has been
	 tightened, but in a way that is completely compatible with the only



Borenstein & Freed																						 [Page 78]

RFC 1521													MIME										September 1993


	 version number defined in RFC 1341.

	 14.	In Section 7.3.1, the definition of message/rfc822 has been
	 relaxed regarding mandatory fields.

	 All other changes from RFC 1341 were editorial changes and do not
	 affect the technical content of MIME.	Considerable formal grammar
	 has been added, but this reflects the prose specification that was
	 already in place.










































Borenstein & Freed																						 [Page 79]

RFC 1521													MIME										September 1993


References

	 [US-ASCII] Coded Character Set--7-Bit American Standard Code for
	 Information Interchange, ANSI X3.4-1986.

	 [ATK] Borenstein, Nathaniel S., Multimedia Applications Development
	 with the Andrew Toolkit, Prentice-Hall, 1990.

	 [GIF] Graphics Interchange Format (Version 89a), Compuserve, Inc.,
	 Columbus, Ohio, 1990.

	 [ISO-2022] International Standard--Information Processing--ISO 7-bit
	 and 8-bit coded character sets--Code extension techniques, ISO
	 2022:1986.

	 [ISO-8859] Information Processing -- 8-bit Single-Byte Coded Graphic
	 Character Sets -- Part 1: Latin Alphabet No. 1, ISO 8859-1:1987.	Part
	 2: Latin alphabet No.	2, ISO 8859-2, 1987.	Part 3: Latin alphabet
	 No. 3, ISO 8859-3, 1988.	Part 4: Latin alphabet No.	4, ISO 8859-4,
	 1988.	Part 5: Latin/Cyrillic alphabet, ISO 8859-5, 1988.	Part 6:
	 Latin/Arabic alphabet, ISO 8859-6, 1987.	Part 7: Latin/Greek
	 alphabet, ISO 8859-7, 1987.	Part 8: Latin/Hebrew alphabet, ISO
	 8859-8, 1988.	Part 9: Latin alphabet No. 5, ISO 8859-9, 1990.

	 [ISO-646] International Standard--Information Processing--ISO 7-bit
	 coded character set for information interchange, ISO 646:1983.

	 [MPEG] Video Coding Draft Standard ISO 11172 CD, ISO IEC/TJC1/SC2/WG11
	 (Motion Picture Experts Group), May, 1991.

	 [PCM] CCITT, Fascicle III.4 - Recommendation G.711, Geneva, 1972,
	 "Pulse Code Modulation (PCM) of Voice Frequencies".

	 [POSTSCRIPT] Adobe Systems, Inc., PostScript Language Reference
	 Manual, Addison-Wesley, 1985.

	 [POSTSCRIPT2] Adobe Systems, Inc., PostScript Language Reference
	 Manual, Addison-Wesley, Second Edition, 1990.

	 [X400] Schicker, Pietro, "Message Handling Systems, X.400", Message
	 Handling Systems and Distributed Applications, E.	Stefferud, O-j.
	 Jacobsen, and P.	Schicker, eds., North-Holland, 1989, pp. 3-41.

	 [RFC-783] Sollins, K., "TFTP Protocol (revision 2)", RFC 783, MIT,
	 June 1981.

	 [RFC-821] Postel, J., "Simple Mail Transfer Protocol", STD 10, RFC
	 821, USC/Information Sciences Institute, August 1982.



Borenstein & Freed																						 [Page 80]

RFC 1521													MIME										September 1993


	 [RFC-822] Crocker, D., "Standard for the Format of ARPA Internet Text
	 Messages", STD 11, RFC 822, UDEL, August 1982.

	 [RFC-934] Rose, M., and E. Stefferud, "Proposed Standard for Message
	 Encapsulation", RFC 934, Delaware and NMA, January 1985.

	 [RFC-959] Postel, J. and J. Reynolds, "File Transfer Protocol",
	 STD 9, RFC 959, USC/Information Sciences Institute, October 1985.

	 [RFC-1049] Sirbu, M., "Content-Type Header Field for Internet
	 Messages", STD 11, RFC 1049, CMU, March 1988.

	 [RFC-1421] Linn, J., "Privacy Enhancement for Internet Electronic Mail:
	 Part I - Message Encryption and Authentication Procedures", RFC
	 1421, IAB IRTF PSRG, IETF PEM WG, February 1993.

	 [RFC-1154] Robinson, D. and R. Ullmann, "Encoding Header Field for
	 Internet Messages", RFC 1154, Prime Computer, Inc., April 1990.

	 [RFC-1341] Borenstein, N., and N.	Freed, "MIME (Multipurpose Internet
	 Mail Extensions): Mechanisms for Specifying and Describing the Format
	 of Internet Message Bodies", RFC 1341, Bellcore, Innosoft, June 1992.

	 [RFC-1342] Moore, K., "Representation of Non-Ascii Text in Internet
	 Message Headers", RFC 1342, University of Tennessee, June 1992.

	 [RFC-1343] Borenstein, N., "A User Agent Configuration Mechanism
	 for Multimedia Mail Format Information", RFC 1343, Bellcore, June
	 1992.

	 [RFC-1344] Borenstein, N., "Implications of MIME for Internet
	 Mail Gateways", RFC 1344, Bellcore, June 1992.

	 [RFC-1345] Simonsen, K., "Character Mnemonics & Character Sets",
	 RFC 1345, Rationel Almen Planlaegning, June 1992.

	 [RFC-1426] Klensin, J., (WG Chair), Freed, N., (Editor), Rose, M.,
	 Stefferud, E., and D. Crocker, "SMTP Service Extension for 8bit-MIME
	 transport", RFC 1426, United Nations Universit, Innosoft, Dover Beach
	 Consulting, Inc., Network Management Associates, Inc., The Branch
	 Office, February 1993.

	 [RFC-1522] Moore, K., "Representation of Non-Ascii Text in Internet
	 Message Headers" RFC 1522, University of Tennessee, September 1993.

	 [RFC-1340] Reynolds, J., and J. Postel, "Assigned Numbers", STD 2, RFC
	 1340, USC/Information Sciences Institute, July 1992.




Borenstein & Freed																						 [Page 81]
